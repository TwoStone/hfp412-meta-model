
	public static String TYPE_LINK_OP = "++";

	public static PersistentMAbstractTypeDisjunction transientCreateAbstrTypeDisj(MTypeSearchList addends)
			throws PersistenceException {
		MTypeSearchList normalizedTypeList = MAbstractTypeDisjunction.normalizeTypeList(addends);

		if (normalizedTypeList.getLength() == 0) {
			return MEmptyTypeDisjunction.getTheMEmptyTypeDisjunction();
		}

		List<PersistentMAtomicTypeConjunction> atomicTypeConjunctions = MAbstractTypeDisjunction
				.filterAtomicTypeConjunctions(normalizedTypeList);

		if (atomicTypeConjunctions.size() == normalizedTypeList.getLength()) {
			return MNonEmptyDisjunctiveNormalForm.transientCreateNEDNF(atomicTypeConjunctions);
		}

		return MMixedTypeDisjunction.transientCreateMixedTypeDisj(normalizedTypeList);
	}

	private static MTypeSearchList normalizeTypeList(MTypeSearchList types) throws PersistenceException {
		final MTypeSearchList result = new MTypeSearchList();
		types.applyToAll(new Procdure<PersistentMType>() {

			@Override
			public void doItTo(PersistentMType argument) throws PersistenceException {
				argument.accept(new MTypeStandardVisitor() {

					@Override
					protected void standardHandling(PersistentMType mType) throws PersistenceException {
						MAbstractTypeDisjunction.addNormalizedToTypeList(result, mType);
					}

					@Override
					public void handleMNonEmptyDisjunctiveNormalForm(
							PersistentMNonEmptyDisjunctiveNormalForm mNonEmptyDisjunctiveNormalForm)
							throws PersistenceException {
						mNonEmptyDisjunctiveNormalForm.getAddends().applyToAll(
								new Procdure<PersistentMAtomicTypeConjunction>() {

									@Override
									public void doItTo(PersistentMAtomicTypeConjunction argument)
											throws PersistenceException {
										MAbstractTypeDisjunction.addNormalizedToTypeList(result, argument);

									}
								});

					}

					@Override
					public void handleMEmptyTypeDisjunction(PersistentMEmptyTypeDisjunction mEmptyTypeDisjunction)
							throws PersistenceException {
						// NEUTRAL ELEMENT
					}

					@Override
					public void handleMMixedTypeDisjunction(PersistentMMixedTypeDisjunction mMixedTypeDisjunction)
							throws PersistenceException {
						mMixedTypeDisjunction.getAddends().applyToAll(new Procdure<PersistentMType>() {

							@Override
							public void doItTo(PersistentMType argument) throws PersistenceException {
								MAbstractTypeDisjunction.addNormalizedToTypeList(result, argument);
							}
						});

					}
				});
			}
		});
		return result;
	}

	private static void addNormalizedToTypeList(MTypeSearchList container, PersistentMType addend)
			throws PersistenceException {
		boolean addType = true;
		Iterator<PersistentMType> iterator = container.iterator();
		while (iterator.hasNext() && addType) {
			PersistentMType currentListType = iterator.next();
			if (addend.isLessOrEqual(currentListType).toBoolean()) {
				addType = false;
			} else if (currentListType.isLessOrEqual(addend).toBoolean()) {
				iterator.remove();
			}
		}
		if (addType) {
			container.add(addend);
		}
	}

	private static List<PersistentMAtomicTypeConjunction> filterAtomicTypeConjunctions(MTypeSearchList typeList)
			throws PersistenceException {
		final List<PersistentMAtomicTypeConjunction> result = Lists.newArrayList();

		typeList.applyToAll(new Procdure<PersistentMType>() {

			@Override
			public void doItTo(PersistentMType argument) throws PersistenceException {
				argument.accept(new MTypeStandardVisitor() {

					@Override
					public void handleMNonEmptyAtomicTypeConjunction(
							PersistentMNonEmptyAtomicTypeConjunction mNonEmptyAtomicTypeConjunction)
							throws PersistenceException {
						result.add(mNonEmptyAtomicTypeConjunction);

					}

					@Override
					public void handleMEmptyTypeConjunction(PersistentMEmptyTypeConjunction mEmptyTypeConjunction)
							throws PersistenceException {
						result.add(mEmptyTypeConjunction);

					}

					@Override
					public void handleMAtomicType(PersistentMAtomicType mAtomicType) throws PersistenceException {
						MAtomicTypeSearchList sl = new MAtomicTypeSearchList();
						sl.add(mAtomicType);
						result.add(MNonEmptyAtomicTypeConjunction.transientCreateNETypeConj(sl));

					}

					@Override
					protected void standardHandling(PersistentMType mType) throws PersistenceException {
						// Do not add
					}
				});
			}
		});
		return result;
	}
	