
	public static String TYPE_LINK_OP = "**";

	public static PersistentMAbstractTypeConjunction transientCreateAbstractTypeConj(MTypeSearchList factors)
			throws PersistenceException, ConsistencyException {
		MTypeSearchList normalizedTypeList = MAbstractTypeConjunction.normalizeTypeList(factors);

		if (normalizedTypeList.getLength() == 0) {
			return MEmptyTypeConjunction.getTheMEmptyTypeConjunction();
		}

		MAbstractTypeConjunction.checkAspectsAreUnique(normalizedTypeList);

		MAtomicTypeSearchList atomicTypes = MAbstractTypeConjunction.filterAtomicTypes(normalizedTypeList);
		if (atomicTypes.getLength() == normalizedTypeList.getLength()) {
			return MNonEmptyAtomicTypeConjunction.transientCreateNETypeConj(atomicTypes);
		}
		return MMixedConjunction.transientCreateMixedTypeConj(normalizedTypeList);
	}

	/**
	 * Normalisiert die Typenliste <tt>types</tt>: F??r jede Konjunktion werden deren Faktoren verwendet, f??r jede
	 * Disjunktion die komplette Disjunktion. Alle Paare von Typen A,B werden bzgl. <= verglichen: Bei A <= B wird nur A
	 * ??bernommen. Stehen A und B nicht bzgl. <= in Relation werden beide ??bernommen
	 * 
	 * @param types
	 *            Typenliste
	 * @return normalisierte Typenliste
	 * @throws PersistenceException
	 */
	private static MTypeSearchList normalizeTypeList(SearchListRoot<PersistentMType> types) throws PersistenceException {
		final MTypeSearchList result = new MTypeSearchList();
		types.applyToAll(new Procdure<PersistentMType>() {

			@Override
			public void doItTo(PersistentMType argument) throws PersistenceException {
				argument.accept(new MTypeVisitor() {

					@Override
					public void handleMNonEmptyAtomicTypeConjunction(
							PersistentMNonEmptyAtomicTypeConjunction mNonEmptyAtomicTypeConjunction)
							throws PersistenceException {
						mNonEmptyAtomicTypeConjunction.getFactors().applyToAll(new Procdure<PersistentMAtomicType>() {

							@Override
							public void doItTo(PersistentMAtomicType argument) throws PersistenceException {
								MAbstractTypeConjunction.addNormalizedToTypeList(result, argument);
							}
						});
					}

					@Override
					public void handleMEmptyTypeConjunction(PersistentMEmptyTypeConjunction mEmptyTypeConjunction)
							throws PersistenceException {
						// Neutral Element => IGNORE
					}

					@Override
					public void handleMMixedConjunction(PersistentMMixedConjunction mMixedConjunction)
							throws PersistenceException {
						mMixedConjunction.getFactors().applyToAll(new Procdure<PersistentMType>() {

							@Override
							public void doItTo(PersistentMType argument) throws PersistenceException {
								MAbstractTypeConjunction.addNormalizedToTypeList(result, argument);
							}
						});
					}

					@Override
					public void handleMNonEmptyDisjunctiveNormalForm(
							PersistentMNonEmptyDisjunctiveNormalForm mNonEmptyDisjunctiveNormalForm)
							throws PersistenceException {
						MAbstractTypeConjunction.addNormalizedToTypeList(result, mNonEmptyDisjunctiveNormalForm);
					}

					@Override
					public void handleMEmptyTypeDisjunction(PersistentMEmptyTypeDisjunction mEmptyTypeDisjunction)
							throws PersistenceException {
						MAbstractTypeConjunction.addNormalizedToTypeList(result, mEmptyTypeDisjunction);
					}

					@Override
					public void handleMMixedTypeDisjunction(PersistentMMixedTypeDisjunction mMixedTypeDisjunction)
							throws PersistenceException {
						MAbstractTypeConjunction.addNormalizedToTypeList(result, mMixedTypeDisjunction);
					}

					@Override
					public void handleMAtomicType(PersistentMAtomicType mAtomicType) throws PersistenceException {
						MAbstractTypeConjunction.addNormalizedToTypeList(result, mAtomicType);
					}
				});
			}
		});
		return result;
	}

	/**
	 * Vergleicht <tt>addend</tt> mit jedem Typen in <tt>container</tt>. Wenn <tt>addend</tt> <= A ??? <tt>container</tt>,
	 * wird A entfernt. Wenn ein oder mehrere A ??? <tt>container</tt> <= <tt>addend</tt>, werden alle A entfernt.
	 * 
	 * @param container
	 * @param addend
	 * @throws PersistenceException
	 */
	private static void addNormalizedToTypeList(MTypeSearchList container, PersistentMType addend)
			throws PersistenceException {
		boolean addType = true;
		Iterator<PersistentMType> iterator = container.iterator();
		while (iterator.hasNext() && addType) {
			PersistentMType currentListType = iterator.next();
			if (currentListType.isLessOrEqual(addend).toBoolean()) {
				addType = false;
			} else if (addend.isLessOrEqual(currentListType).toBoolean()) {
				iterator.remove();
			}
		}
		if (addType) {
			container.add(addend);
		}
	}

	private static void checkAspectsAreUnique(MTypeSearchList typeList) throws ConsistencyException,
			PersistenceException {
		Iterator<PersistentMType> iterator = typeList.iterator();
		MAspectSearchList currentMergeList = new MAspectSearchList();
		if (iterator.hasNext()) {
			currentMergeList.add(iterator.next().fetchAspects());
		}
		while (iterator.hasNext()) {
			MAbstractTypeConjunction.mergeAspectListsUnique(currentMergeList, iterator.next().fetchAspects());
		}
	}

	private static MAspectSearchList mergeAspectListsUnique(MAspectSearchList listA, MAspectSearchList listB)
			throws ConsistencyException, PersistenceException {
		final MAspectSearchList result = new MAspectSearchList(listA);
		listB.applyToAllException(new ProcdureException<PersistentMAspect, ConsistencyException>() {

			@Override
			public void doItTo(PersistentMAspect argument) throws PersistenceException, ConsistencyException {
				final PersistentMAspect currentBAspect = argument;
				result.applyToAllException(new ProcdureException<PersistentMAspect, ConsistencyException>() {

					@Override
					public void doItTo(PersistentMAspect argument) throws PersistenceException, ConsistencyException {
						if (argument.equals(currentBAspect)) {
							throw new ConsistencyException("Aspects in TypeConjunctions must be unique.");
						}
					}
				});
				result.add(currentBAspect);
			}
		});
		return result;
	}

	private static MAtomicTypeSearchList filterAtomicTypes(MTypeSearchList typeList) throws PersistenceException {
		final MAtomicTypeSearchList result = new MAtomicTypeSearchList();
		typeList.applyToAll(new Procdure<PersistentMType>() {

			@Override
			public void doItTo(PersistentMType argument) throws PersistenceException {
				argument.accept(new MTypeVisitor() {

					@Override
					public void handleMNonEmptyAtomicTypeConjunction(
							PersistentMNonEmptyAtomicTypeConjunction mNonEmptyAtomicTypeConjunction)
							throws PersistenceException {
						// DO NOTHING
					}

					@Override
					public void handleMEmptyTypeConjunction(PersistentMEmptyTypeConjunction mEmptyTypeConjunction)
							throws PersistenceException {
					}

					@Override
					public void handleMMixedConjunction(PersistentMMixedConjunction mMixedConjunction)
							throws PersistenceException {
					}

					@Override
					public void handleMNonEmptyDisjunctiveNormalForm(
							PersistentMNonEmptyDisjunctiveNormalForm mNonEmptyDisjunctiveNormalForm)
							throws PersistenceException {
					}

					@Override
					public void handleMEmptyTypeDisjunction(PersistentMEmptyTypeDisjunction mEmptyTypeDisjunction)
							throws PersistenceException {
					}

					@Override
					public void handleMMixedTypeDisjunction(PersistentMMixedTypeDisjunction mMixedTypeDisjunction)
							throws PersistenceException {
					}

					@Override
					public void handleMAtomicType(PersistentMAtomicType mAtomicType) throws PersistenceException {
						result.add(mAtomicType);

					}
				});
			}
		});
		return result;
	}
	