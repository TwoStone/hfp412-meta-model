model metaModel{


/*** SERVER ***/

server Server {
	/**** Manager ****/
	derived AspectManager aspectManager;
	derived TypeManager typeManager;
	derived QuantityManager quantityManager;
	derived UnitTypeManager unitTypeManager;
	derived FractionManager fractionManager;

	derived MeasurementTypeManager measurementTypeManager;
	derived AccountTypeManager accountTypeManager;
	derived AccountManager accountManager;

	derived ObjectManager objectManager;
	derived NameSchemeManager nameSchemeManager;
	derived NameSchemeInstaceManager nameSchemeInstanceManager;

	/** Type **/
	void createAspect(AspectManager aspectManager, String name);
	void createAtomicRootType(MAspect aspect, String typeName, MBooleanSUBTYPEName singletonType, MBooleanSUBTYPEName abstractType);
	void createAtomicSubType(MAtomicType superType, String typeName, MBooleanSUBTYPEName singletonType, MBooleanSUBTYPEName abstractType);
	void createSumType(MType** containees{typeManager;types});
	void createProductType(MType** containees{typeManager;types});
	//	void addSubType@@Bestehenden_Typ_unterordnen(MAtomicType superType, MAtomicType subType@@Untertyp{typeManager;atomicTypes});

	void createMObject@@Exemplar_erstellen(MAtomicType type {typeManager;types}, MAtomicType** otherTypes {typeManager;types});	
	void addType@@Typen_hinzuf?gen(MObject object, MAtomicType newType {typeManager;types});
	void removeType@@Typen_entfernen(MObject object, MAtomicType oldType {;object;types});
	void replaceType@@Typen_ersetzen(MObject object, MAtomicType oldType {;object;types}, MAtomicType newType {;oldType;aspect;types});

	/** Manager zu AbstractOperation **/
	derived AssociationManager associationManager;
	derived OperationManager operationManager;
	derived MessageManager messageManager;
	derived LinkManager linkManager;

	/** Associations und Hierarchy **/
	void createAssociation(AssociationManager manager, MType source, MType target, String name);
	void removeAssociation(Association a);
	void createHierarchy(AssociationManager manager, Association a, String name);
	void createHierarchy(Association a, String name);

	void addAssociation(Hierarchy h, Association a);
	void addToHierarchy(Association association, Hierarchy theHierarchy);
	void removeFromHierarchy(Hierarchy h, Association a);

	/** Operations **/
	void createConstant(OperationManager operationManager, String name, MType target);
	void createStaticOp(OperationManager operationManager, String name, MType target, FormalParameter** fp);
	void createOperation(OperationManager operationManager, MType source, MType target, String name, FormalParameter** fp);
	void createOperation(MType source, MType target, String name, FormalParameter** fp);

	void createVoidOperation(OperationManager operationManager, MType source, String name, FormalParameter** fp);
	void createVoidOperation(MType source, String name, FormalParameter** fp);
 	void createFp@@createFormalParameter(OperationManager operationManager, String name, MType ofType);

	void addFp@@addFormalParameter(Operation op, FormalParameter fp);
	void removeFpFromOp@@removeFormalParameter(Operation operation, FormalParameter fp); 
	void removeFp@@removeFormalParameter(FormalParameter fp);
	void removeOperation(Operation op);

	/** Messages **/
	void createMessage(MessageManager manager, Operation type, InstanceObject source, InstanceObject target, ActualParameter** ap);
	void createMessage(InstanceObject source, Operation type, InstanceObject target, ActualParameter** ap);

	void createVoidMessage(MessageManager manager, Operation type, InstanceObject source, ActualParameter** ap);
	void createVoidMessage(InstanceObject source, Operation type, ActualParameter** ap);

	void createConst@@createConstant(MessageManager manager, Operation type, String name, InstanceObject target);
	void createStaticMessage(MessageManager manager, Operation type, String name, InstanceObject target, ActualParameter** ap);
	void removeMessage(Message m);

	/** Links **/
	void createLink(LinkManager link, Association type, InstanceObject source, InstanceObject target);
	void createLink(InstanceObject source, Association type, InstanceObject target);
	void removeLink(Link link);

	
	/** Quantity/Unit **/
	void createUnitType@@Create_unit_type(UnitTypeManager manager, String name);
	void createCompUnitType@@Create_compound_unit_type(UnitTypeManager manager, String name);
	void removeUnitType(AbsUnitType type);
	void addReferenceType(CompUnitType compUnitType, UnitType unitType {unitTypeManager;atomicUnitTypes}, Integer exponent);
	void finishModeling@@Publish(CompUnitType compUnitType);
	void createUnit@@Create_unit(UnitType type, String name);
	void createCompUnit(CompUnitType compUnitType, String name);
	void removeUnit(AbsUnit unit);
	void addReference(CompUnit compUnit, Unit unit{unitTypeManager;units}, Integer exponent);
	void createQuantity@@Create_quantity(QuantityManager manager, AbsUnit unit, Fraction f);
	void setConversion(Unit unit, Fraction factor, Fraction constant);
	void setDefaultUnit(UnitType type, Unit defaultUnit);

	/** computing **/
	AbsQuantity add(AbsQuantity summand1, AbsQuantity summand2);
	AbsQuantity sub(AbsQuantity minuend, AbsQuantity subtrahend);
	AbsQuantity mul(AbsQuantity factor1, AbsQuantity factor2);
	AbsQuantity div(AbsQuantity dividend, AbsQuantity divisor);

	/** Measurement/Account **/
	void createMeasurementType@@Messungstyp_anlegen(MeasurementTypeManager measurementTypeManager, String name, MType type {typeManager;types}, UnitType unitType {unitTypeManager;atomicUnitTypes});
	void createAccountType@@Kontotyp_anlegen(AccountTypeManager accountTypeManager, String name, MType type {typeManager;types}, UnitType unitType {unitTypeManager;atomicUnitTypes});
	void createAccount@@Konto_anlegen(AccountManager accountManager, String name, MAccountType type {accountTypeManager;accountTypes}, InstanceObject object);


 	/** Naming **/
	void createNameScheme(String schemeName, String regExp);
	void assignType(NameScheme scheme, MAtomicType type);
	void assignName(MObject object, Name scheme {;object;types}, String name);
}



part typeSystem {
	
	/* Abstrakte Typen */
	abstract class MType@@Type {
		abstract String fetchName();
		abstract MBoolean isLessOrEqual(MType other);
		abstract MBoolean isSingleton();
		abstract MBoolean isAbstract();
		abstract MBoolean isStructuralEquivalant(MType other);  	/*		
			MSumType fetchDisjunctiveNormalform();
			MAssociation** fetchAssociations();
			MBoolean allObjectsOfTypeAreSingleton();

			MBoolean isLessOrEqual(MType otherType); 
			MBoolean isStructuralEqual(MType otherType); 
			MBoolean contains(MType otherType);
			*/
	}

	/* Aspekte */
	class MAspect@@Aspect {
		prior indexed String name; 

		derived MAtomicType ** types;
	}
	
	/* Atomare Typen */
	class MAtomicType@@AtomicType extends MType {
		prior indexed String name;
		client-as-string prior MBoolean singletonType;
		client-as-string prior MBoolean abstractType;
		no-view prior symmetric(types) MAspect aspect;
		no-view symmetric(subTypes) MAtomicType superType hierarchy MAtomicTypeHierarchy;
		
		MBoolean hasConcreteSubType();	
		/*
			void addSubType(MAtomicType typeunder) throws CycleException, WrongSubTypeAspectException;
			MBoolean transitiveHasConcreteSubtype();
			*/
	}
	
	/* Komplexe Typen*/
	abstract class MComplexType@@ComplexType extends MType {
		MType** containedTypes hierarchy MComplexTypeHierarchy;
		abstract String fetchTypeLinkOperator();
	}
	
	/* ++ Summentypen ++ */
	abstract class MAbstractSumType##MAbstrSum@@AbstractSumType extends MComplexType {
	}
	
	singleton MEmptySumType@@EmptySumType extends MAbstractSumType {
	}
	
	class MSumType@@SumType extends MAbstractSumType {
	}

	/* ** Produkttypen ** */
	abstract class MAbstractProductType##MAbstrProd@@AbstractProductType extends MComplexType {
	}

	singleton MEmptyProductType##MEmptProd@@EmptyProductType extends MAbstractProductType{
	}
	
	class MProductType@@ProductType extends MAbstractProductType {
	}
	
	/* Objekte */
	class MObject {
		MAtomicType ** types;

		void addType(MAtomicType newType) throws ConsistencyException;
		void removeType(MAtomicType oldType) throws ConsistencyException;
		void replaceType(MAtomicType oldType, MAtomicType newType) throws ConsistencyException; 
	}

	/*** MANAGER ***/
	/* Manager  for Aspects */
	singleton AspectManager {
		MAspect** aspects;
		active MAspect createAspect(String name) throws ConsistencyException;
	}
	/* Manager for Types */
	singleton TypeManager {
		MType** types;
		
		active MAtomicType createAtomicRootType(MAspect aspect, String name, MBoolean singletonType, MBoolean abstractType) 
			throws ConsistencyException;
		active MAtomicType createAtomicSubType(MAtomicType superType, String name, MBoolean singletonType, MBoolean abstractType) 
			throws ConsistencyException;
		active MAbstractSumType createSumType(MType** addends) throws ConsistencyException;
		active MAbstractProductType createProductType(MType** factors) throws ConsistencyException;
		

		
		
		//active void addSubType(MAtomicType superType, MAtomicType subType) throws CycleException, ConsistencyException;
	}
	
	singleton ObjectManager {
		MObject** objects;
		
		active MObject createMObject(MAtomicType type, MAtomicType** otherTypes) throws ConsistencyException		
		active void addType(MObject object, MAtomicType newType) throws ConsistencyException;
		active void removeType(MObject object, MAtomicType oldType) throws ConsistencyException;
		active void replaceType(MObject object, MAtomicType oldType, MAtomicType newType) throws ConsistencyException;
	}
	
	
	/*** HIERARCHIES ***/
	/* Partielle Ordnung "<=" auf atomaren Typen */
	hierarchy MAtomicTypeHierarchy##MATypeHier;
	/* Partielle Ordnung "enthalten sein" auf allen Typen */
	hierarchy MComplexTypeHierarchy##MCTypeHier;
}





part quantity {

	abstract class AbsQuantity {
	
		AbsQuantity add(AbsQuantity summand);
		AbsQuantity sub(AbsQuantity subtrahend);
		AbsQuantity mul(AbsQuantity factor);
		AbsQuantity div(AbsQuantity divisor);
	}

	class Quantity extends AbsQuantity {
		prior Fraction amount;
		prior AbsUnit unit;
	}

	class CompoundQuantity extends AbsQuantity {
		Quantity ** parts; // +
	}

	abstract class AbsUnit {
		no-view prior AbsUnitType type; // 1
		indexed prior String name;
	}

	class CompUnit extends AbsUnit {
		Reference ** refs;
		no-view MBoolean isFinal;
		void finishModeling() throws AlreadyFinalizedException, ExponentMatchingException;
		MBoolean isFinal();
		
		/* Pr?ft, ob Exponenten der Exemplarebene mit Typebene ?bereinstimmen*/
		void checkExponents() throws ExponentMatchingException;
	}
	class Unit extends AbsUnit {	}

	abstract class AbsUnitType {
		indexed prior String name;
	}

	class CompUnitType extends AbsUnitType {
		ReferenceType ** refs;	
		no-view MBoolean isFinal;
		void finishModeling() throws AlreadyFinalizedException;
		MBoolean isFinal();
	}

	class UnitType extends AbsUnitType {
		Unit defaultUnit;
	}

	class ReferenceType {
		Integer exponent;
		no-view UnitType ref;
	}
	class Reference {
		ReferenceType type;
		Integer exponent;
		Unit ref;
	}
	
	class Conversion {
		// from und to sind Oracle-Schluesselwoerter.
		prior no-view one-to-one (myConversion) Unit source;
		prior Function myFunction;

		Quantity convert(Fraction amount);
		Quantity convertInverse(Fraction amount);
	}

	class Function {
		prior Fraction factor;
		prior Fraction constant;
		//indexed String name; factor*x+constant
		Fraction execute(Fraction amount);
		Fraction executeInverse(Fraction amount);
	}


	/*
	* Manager
	*/
	singleton UnitTypeManager {
		AbsUnitType ** unitTypes;
		derived UnitType** atomicUnitTypes;
		AbsUnit ** units;
	
		/* Operationen fuer Typebene */
		active void createUnitType(String name) throws DoubleDefinitionException;
		active void createCompUnitType(String name) throws DoubleDefinitionException;
		active void removeUnitType(AbsUnitType type);
		active void finishModeling(CompUnitType compUnitType) throws AlreadyFinalizedException;
		active void setDefaultUnit(UnitType type, Unit unit);
		active void addReferenceType(CompUnitType compUnitType, UnitType unitType, Integer exponent) 
			throws DoubleDefinitionException, AlreadyFinalizedException;

		/* Operationen fuer Exemplarebene */
		active void createUnit(String name, UnitType type) throws DoubleDefinitionException;
		active void createCompUnit(String name, CompUnitType type) throws DoubleDefinitionException, NotFinalizedException;
		active void removeUnit(AbsUnit unit);
		active void addReference(CompUnit compUnit, Unit unit, Integer exponent) throws DoubleDefinitionException;
		active void setConversion(Unit unit, Fraction factor, Fraction constant);
	}

	singleton QuantityManager {
		AbsQuantity ** quantities;
		active Quantity createQuantity(AbsUnit unit, Fraction amount);
	}

	/*Jeder Bruch nur einmal vorhanden*/
	singleton FractionManager {
	//	Fraction ** fractions;
	}

	singleton FunctionManager {
		Function** functions;
	}
}


/* Deprecated */
class InstanceObject {
	prior MAtomicType type;
}

part abstractOperation {

/*** MANAGER ***/
singleton AssociationManager {
	Association ** associations;
	Hierarchy** hierarchies;

active void createAssociation(MType source, MType target, String name) throws DoubleDefinitionException;
active void removeAssociation(Association a) throws CycleException, ConsistencyException;
active void createHierarchy(Association a, String name) throws DoubleDefinitionException;

active void addAssociation(Hierarchy h, Association a) throws DoubleDefinitionException, CycleException;
active void removeAssoFrmHier(Hierarchy h, Association a) throws CycleException, NotAvailableException;
}

singleton OperationManager {
	Operation ** operations; // TODO: Typunterscheidung (spezialisierung static/nonstatic & constants)
	derived Operation** staticOperations;
	derived Operation** constants;
	FormalParameter ** formalParameters;

active void createConstant(String name, MType target) throws DoubleDefinitionException;
active void createStaticOp(String name, MType target, FormalParameter** fp) throws DoubleDefinitionException;
active void createOperation(MType source, MType target, String name, FormalParameter** fp) throws DoubleDefinitionException;
active void createVoidOperation(MType source, String name, FormalParameter** fp) throws DoubleDefinitionException;
active void createFp(String name, MType ofType) throws DoubleDefinitionException;

active void addFp(Operation op, FormalParameter fp) throws ConsistencyException;
active void addMultipleFp(Operation op, FormalParameter** fp);
active void removeFpFromOp(Operation op, FormalParameter fp);
active void removeFp(FormalParameter fp) throws ConsistencyException;
active void removeOperation(Operation op) throws ConsistencyException;
}

class FormalParameter {
    prior MType ofType;
    indexed prior String name;
}

abstract class AbsOperation@@AbstractOperation {
    indexed prior String name;
    prior symmetric MType source;
    prior MType target;
    FormalParameter ** parameters;
}

class Association extends AbsOperation {
	symmetric(associations) Hierarchy** hierarchies; 

	MBoolean isObservation();
}

class Operation extends AbsOperation {
	MBoolean isStatic();
}


class Hierarchy {
	prior indexed String name;
}

}

part messageOrLink {

singleton MessageManager{
Message** messages;

active void createMessage(Operation type, InstanceObject source, InstanceObject target, ActualParameter** ap) throws DoubleDefinitionException, ConsistencyException;
active void createVoidMessage(Operation type, InstanceObject source, ActualParameter** ap) throws DoubleDefinitionException, ConsistencyException;
active void createConst(Operation type, String name, InstanceObject target) throws DoubleDefinitionException, ConsistencyException;
active void createStaticMessage(Operation type, String name, InstanceObject target, ActualParameter** ap) throws DoubleDefinitionException, ConsistencyException;
active void removeMessage(Message m);
}

singleton LinkManager {
Link** links;

active void createLink(Association type, InstanceObject source, InstanceObject target);
active void removeLink(Link link);
}

abstract class MessageOrLink {
    prior InstanceObject source;
    prior InstanceObject target;
}

// TODO: Was ist mit statische Methoden und Methoden die void zurueck geben sollen? Source/Target 0..1? Eventuell noch mal spezialisieren
class Message extends MessageOrLink {
   prior symmetric Operation type;
	ActualParameter** actualParameters;
}

class ActualParameter {
    prior FormalParameter type;
    prior InstanceObject value;
}

class Link extends MessageOrLink {
    prior Association type;
}
}


part basic {
	/* Boolean */
	string-factory abstract class MBoolean(MTrue@@true, MFalse@@false){
		extern boolean toBoolean();	
		MBoolean invert();
	}
}


part measurement {

singleton MeasurementTypeManager##MsrmntTpMng {
	MMeasurementType** measurementTypes;
	active void createMeasurementType(String name, MType type, UnitType unitType);
}

singleton AccountTypeManager {
	MAccountType** accountTypes;
	active void createAccountType(String name, MType type, UnitType unitType);
}

singleton AccountManager {
	Account** accounts;
	active void createAccount(String name, MAccountType type, InstanceObject object);
}

abstract class MQuantiObjectType@@QuantifiedObjectType {
	prior MType type;
	prior AbsUnitType unitType;
}

class MMeasurementType@@MeasurementType extends MQuantiObjectType {
}

hierarchy MAccountTypeHierarchy##MAccTypeHie;
class MAccountType@@AccountType extends MQuantiObjectType {
	MAccountType** subAccountTypes hierarchy MAccountTypeHierarchy;
}


abstract class QuantifObject@@QuantifiedObject {
	symmetric prior InstanceObject object;
	// TODO: aggregate(s:AggregationStrategy) : Quantity
}

class Measurement extends QuantifObject {
	prior MMeasurementType type;
	// TODO: Eventuell erst spaeter, wenn der Type feststeht, die Quantitaet setzen?
	prior AbsQuantity quantity;
}

hierarchy AccountHierarchy##AccountHie;
class Account extends QuantifObject {
	prior MAccountType type;
	Account** subAccounts hierarchy AccountHierarchy;
	Measurement** entries;
}

}


part naming {
	class Name {
		prior symmetric (possibleNames) MAtomicType fromType;
		prior NameScheme nameScheme;
	}
	
	class NameInstance {
		prior Name type;
		prior symmetric(names) MObject fromObject;
		prior NameSchemeInstance nameScheme;
	}


	class NameScheme {
		prior String regExpPattern;
		indexed String name;

		MBoolean match(String name);
	}


	class NameSchemeInstance##NSInst {
		prior String name;
		prior symmetric (names) NameScheme type;
	}
	

	singleton NameSchemeManager {
		NameScheme ** schemes;

		active NameScheme createNameScheme(String regExpPattern);
		active void assignNameScheme(MAtomicType type, NameScheme nameScheme);
	}

	singleton NameSchemeInstaceManager##NSIMngr {
		active NameSchemeInstance createInstance(String name, NameScheme scheme) throws PatternNotMatchException;
	
		active void assignName(MObject object, Name name, String value) throws PatternNotMatchException;
	}
}


/*** EXCEPTIONS ***/
exception PatternNotMatchException{}
exception DoubleDefinitionException{}
exception ConsistencyException{}
exception WrongSubTypeAspectException{}

exception NotAvailableException{}

exception AlreadyFinalizedException{}
exception NotFinalizedException{}
exception ExponentMatchingException{}

}