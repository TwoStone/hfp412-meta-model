model metaModel{


/*** SERVER ***/

server Server {
	/**** Manager ****/
	derived AspectManager aspectManager;
	derived TypeManager typeManager;
	derived QuantityManager quantityManager;
	derived UnitTypeManager unitTypeManager;
	derived FractionManager fractionManager;

	derived MeasurementTypeManager measurementTypeManager;
	derived AccountTypeManager accountTypeManager;
	derived AccountManager accountManager;

	derived ObjectManager objectManager;
	derived NameSchemeManager nameSchemeManager;

	/** Type **/
	void createAspect(AspectManager aspectManager, String name);
	void createAtomicRootType(MAspect aspect, String typeName, MBooleanSUBTYPEName singletonType, MBooleanSUBTYPEName abstractType);
	void createAtomicSubType(MAtomicType superType, String typeName, MBooleanSUBTYPEName singletonType, MBooleanSUBTYPEName abstractType);
	void createTypeDisjunction(MType** containees{typeManager;types});
	void createTypeConjunction(MType** containees{typeManager;types});
	//	void addSubType@@Bestehenden_Typ_unterordnen(MAtomicType superType, MAtomicType subType@@Untertyp{typeManager;atomicTypes});

	/** Object **/
	void createMObject@@Exemplar_erstellen(MAtomicType type {typeManager;types}, MAtomicType** otherTypes {typeManager;types});	
	void addType@@Typen_hinzuf?gen(MObject object, MAtomicType newType {typeManager;types});
	void removeType@@Typen_entfernen(MObject object, MAtomicType oldType {;object;types});
	void replaceType@@Typen_ersetzen(MObject object, MAtomicType oldType {;object;types}, MAtomicType newType {;oldType;aspect;types});

	/** Manager zu AbstractOperation **/
	derived AssociationManager associationManager;
	derived OperationManager operationManager;
	derived MessageManager messageManager;
	derived LinkManager linkManager;

	/** Associations und Hierarchy **/
	void createAssociation(AssociationManager manager, MType source, MType target, String name);
	void removeAssociation(Association a);
	void createHierarchy(AssociationManager manager, Association a, String name);
	void createHierarchy(Association a, String name);

	void addAssociation(Hierarchy h, Association a);
	void addToHierarchy(Association association, Hierarchy theHierarchy);
	void removeFromHierarchy(Hierarchy h, Association a);

	/** Operations **/
	void createConstant(OperationManager operationManager, String name, MType target {typeManager;types});
	void createStaticOp(OperationManager operationManager, String name, MType target {typeManager;types}, FormalParameter** fp {operationManager;formalParameters});
	void createOperation(OperationManager operationManager, MType source {typeManager;types}, MType target {typeManager;types}, String name, FormalParameter** fp {operationManager;formalParameters});
	void createOperation(MType source {typeManager;types}, MType target {typeManager;types}, String name, FormalParameter** fp {operationManager;formalParameters});

	void createVoidOperation(OperationManager operationManager, MType source {typeManager;types}, String name, FormalParameter** fp);
	void createVoidOperation(MType source, String name, FormalParameter** fp {operationManager;formalParameters});
 	void createFp@@createFormalParameter(OperationManager operationManager, String name, MType ofType {typeManager;types});

	void addFp@@addFormalParameter(Operation op, FormalParameter fp {operationManager;formalParameters});
	void removeFpFromOp@@removeFormalParameter(Operation operation, FormalParameter fp); 
	void removeFp@@removeFormalParameter(FormalParameter fp);
	void removeOperation(Operation op);

	/** Links **/
	void createLink(LinkManager link, Association type, MObject source, MObject target);
	void createLink(MObject source, Association type, MObject target);
	void removeLink(Link link);

	/** Quantity/Unit **/
	void createUnitType@@Create_unit_type(UnitTypeManager manager, String name);
	void createCompUnitType@@Create_compound_unit_type(UnitTypeManager manager, String name);
	void removeUnitType(AbsUnitType type);
	void addReferenceType(AbsUnitType unitType, String name, UnitType referenceUnitType {unitTypeManager;atomicUnitTypes}, Integer exponent);
	void createUnit@@Create_unit(UnitType type, String name);
	void createCompUnit(CompUnitType compUnitType, String name);
	void removeUnit(AbsUnit unit);
	void addReference(AbsUnit unit, String name, Unit referenceUnit{unitTypeManager;units}, Integer exponent);
	void createQuantity@@Create_quantity(QuantityManager manager, AbsUnit unit, Fraction f);
	void setConversion(Unit unit, Fraction factor, Fraction constant);
	void setDefaultUnit(UnitType type, Unit defaultUnit);
	void convertToDefault(Quantity quantity);
	void convert(Quantity quantity, AbsUnit unit);

	/** computing **/
	AbsQuantity add(AbsQuantity summand1, AbsQuantity summand2) throws NotComputableException;
	AbsQuantity sub(AbsQuantity minuend, AbsQuantity subtrahend) throws NotComputableException;
	AbsQuantity mul(AbsQuantity factor1, AbsQuantity factor2) throws NotComputableException;
	AbsQuantity div(AbsQuantity dividend, AbsQuantity divisor) throws NotComputableException;

	/** Measurement/Account **/
	void createMeasurementType@@Messungstyp_anlegen(MeasurementTypeManager measurementTypeManager, String name, MType type {typeManager;types}, UnitType unitType {unitTypeManager;atomicUnitTypes});
	void createAccountType@@Kontotyp_anlegen(AccountTypeManager accountTypeManager, String name, MType type {typeManager;types}, UnitType unitType {unitTypeManager;atomicUnitTypes});
	void addSubAccountType@@Kontotyp_unterordnen(MAccountType parent, MAccountType child) throws CycleException;
	void createAccount@@Konto_anlegen(AccountManager accountManager, String name, MAccountType type {accountTypeManager;accountTypes}, MObject object);
	void addSubAccount@@Konto_unterordnen(Account parent, Account child) throws CycleException;
	void createEntry@@Eintrag_anlegen(Account account, MObject object{objectManager;objects}, MMeasurementType measurementType{measurementTypeManager;measurementTypes}, Quantity quantity{quantityManager;quantities}) throws ConsistencyException;


 	/** Naming **/
	void createNameScheme@@Namensschema_erstellen(NameSchemeManager manager, String schemeName, String regExp, MBooleanSUBTYPEName isIterable);
	void assignType@@Typen_zuordnen(NameScheme scheme, MAtomicType type);
	void assignNameScheme@@Namensschema_zuordnen(MAtomicType type, NameScheme scheme {nameSchemeManager;schemes});
	void assignName@@Benennen(MObject object, Name scheme {;object;types}, String name);
}

abstract class MModelItem {
	derived MModelItem** dependentItems;
	// TemplateMethod
	void delete() throws ConsistencyException;
	abstract void prepareForDeletion() throws ConsistencyException;
}



part typeSystem {
	
	/* Abstrakte Typen */
	abstract class MType@@Type covers MModelItem{
		abstract String fetchName();
		abstract MBoolean isLessOrEqual(MType other);
		abstract MBoolean isSingleton();
		abstract MBoolean isAbstract();
		abstract MBoolean isStructuralEquivalant(MType other);  			
		abstract MDisjunctiveNormalForm fetchDisjunctiveNormalform();
		abstract MAspect** fetchAspects();
/*
			MAssociation** fetchAssociations();
			MBoolean allObjectsOfTypeAreSingleton();

			MBoolean isLessOrEqual(MType otherType); 
			MBoolean isStructuralEqual(MType otherType); 
			MBoolean contains(MType otherType);
			*/
	}

	/* Aspekte */
	class MAspect@@Aspect {
		prior indexed String name; 

		derived MAtomicType ** types;
	}
	
	/* Atomare Typen */
	class MAtomicType@@AtomicType extends MType {
		prior indexed String name;
		client-as-string prior MBoolean singletonType;
		client-as-string prior MBoolean abstractType;
		no-view prior symmetric(types) MAspect aspect;
		no-view symmetric(subTypes) MAtomicType superType hierarchy MAtomicTypeHierarchy;
		
		MBoolean hasConcreteSubType();	
			//void addSubType(MAtomicType typeunder) throws CycleException, WrongSubTypeAspectException;
	}
	
	/* Komplexe Typen*/
	abstract class MComplexType@@ComplexType extends MType {
		derived MType** containedTypes;
		// MType** containedTypes hierarchy MComplexTypeHierarchy;
		abstract String fetchTypeLinkOperator();
	}

	/* ODER Typen */

	abstract class MAbstractTypeDisjunction##MAbstrDisj@@AbstractTypeDisjunction extends MComplexType {
	}
	
	abstract class  MDisjunctiveNormalForm##DisjNF extends MAbstractTypeDisjunction {
		abstract MDisjunctiveNormalForm transientMultiply(MDisjunctiveNormalForm other);
	}	


	/* Nothing */	
	singleton MEmptyTypeDisjunction##ETDisj@@EmptySumType extends MDisjunctiveNormalForm {
	}

	class MNonEmptyDisjunctiveNormalForm##NEDisjNF extends MDisjunctiveNormalForm {
  		MAtomicTypeConjunction** addends hierarchy MComplexTypeHierarchy;
		
		MNonEmptyDisjunctiveNormalForm transientMultiplyNonEmpty(MNonEmptyDisjunctiveNormalForm other);
	}
	
	class MMixedTypeDisjunction##MxdTpDisj@@MixedTypeDisjunction extends MAbstractTypeDisjunction {
		MType** addends hierarchy MComplexTypeHierarchy;
	}
	

	/* Und Typen */ 
	
	abstract class MAbstractTypeConjunction##AbsTpConj extends MComplexType {}
		

	
	abstract class MAtomicTypeConjunction##ATConj extends MAbstractTypeConjunction {
	MAtomicTypeConjunction transientMultiply(MAtomicTypeConjunction other);
	}
	
			/* Anything */
	singleton MEmptyTypeConjunction##ETpConj@@EmptyTypeConjunction extends MAtomicTypeConjunction {}

	class MNonEmptyAtomicTypeConjunction##NEATConj extends MAtomicTypeConjunction{
		MAtomicType** factors hierarchy MComplexTypeHierarchy;
		MNonEmptyAtomicTypeConjunction transientMultiplyNonEmpty(MNonEmptyAtomicTypeConjunction other);
	}

	class MMixedConjunction extends MAbstractTypeConjunction {
		MType** factors hierarchy MComplexTypeHierarchy;
	}
		
	abstract class AbstractObject##AbsObj {
		derived Name ** possibleNames;
		derived MNonEmptyAtomicTypeConjunction productType;
	}

	/* Objekte */
	class MObject extends AbstractObject {
		MAtomicType ** types;
		derived Link** linksFromMe;
		derived Link** linksToMe;
		void addType(MAtomicType newType) throws ConsistencyException;
		void removeType(MAtomicType oldType) throws ConsistencyException;
		void replaceType(MAtomicType oldType, MAtomicType newType) throws ConsistencyException; 
		MBoolean containsInHierarchies(MObject obj, Hierarchy** hieracs);
		MBoolean containsInHierarchy(MObject obj, Hierarchy hierac);
	}

	class MSingletonObject##SngltnObj extends AbstractObject {
		prior final MAtomicType type;
	}

	/*** MANAGER ***/
	/* Manager  for Aspects */
	singleton AspectManager {
		MAspect** aspects;
		active MAspect createAspect(String name) throws ConsistencyException;
	}
	/* Manager for Types */
	singleton TypeManager {
		MType** types;
		
		active MAtomicType createAtomicRootType(MAspect aspect, String name, MBoolean singletonType, MBoolean abstractType) 
			throws ConsistencyException;
		active MAtomicType createAtomicSubType(MAtomicType superType, String name, MBoolean singletonType, MBoolean abstractType) 
			throws ConsistencyException;
		active MAbstractTypeDisjunction createTypeDisjunction##crTpDisj(MType** addends) throws ConsistencyException;
		active MAbstractTypeConjunction createTypeConjunction##crTpConj(MType** factors) throws ConsistencyException;
		

		
		
		//active void addSubType(MAtomicType superType, MAtomicType subType) throws CycleException, ConsistencyException;
	}
	
	singleton ObjectManager {
		MObject** objects;
		
		active MObject createMObject(MAtomicType type, MAtomicType** otherTypes) throws ConsistencyException		
		active void addType(MObject object, MAtomicType newType) throws ConsistencyException;
		active void removeType(MObject object, MAtomicType oldType) throws ConsistencyException;
		active void replaceType(MObject object, MAtomicType oldType, MAtomicType newType) throws ConsistencyException;
		
		MObject** fetchObjectsWithTypeLE(MType type);

	}
	
	
	/*** HIERARCHIES ***/
	/* Partielle Ordnung "<=" auf atomaren Typen */
	hierarchy MAtomicTypeHierarchy##MATypeHier;
	/* Partielle Ordnung "enthalten sein" auf allen Typen */
	hierarchy MComplexTypeHierarchy##MCTypeHier;
}





part quantity {

	abstract class AbsQuantity {
	
		AbsQuantity add(AbsQuantity summand) throws NotComputableException;
		AbsQuantity sub(AbsQuantity subtrahend) throws NotComputableException;
		AbsQuantity mul(AbsQuantity factor) throws NotComputableException;
		AbsQuantity div(AbsQuantity divisor) throws NotComputableException;
		MBoolean isLessOrEqualThan(AbsQuantity compareValue) throws UserException;
		abstract AbsUnit fetchDefaultUnit();
	}

	class Quantity extends AbsQuantity {
		prior Fraction amount;
		prior AbsUnit unit;
	}

	class CompoundQuantity extends AbsQuantity {
		Quantity ** parts; // +
	}

	abstract class AbsUnit {
		symmetric no-view prior AbsUnitType type; // 1
		indexed prior String name;
	}

	class CompUnit extends AbsUnit {
		symmetric Reference ** refs;
		
		/* Pr?ft, ob Exponenten der Exemplarebene mit Typebene ?bereinstimmen*/
		void checkExponents() throws ExponentMatchingException;
	}
	class Unit extends AbsUnit {	}

	abstract class AbsUnitType {
		indexed prior String name;
	}

	class CompUnitType extends AbsUnitType {
	 	symmetric ReferenceType ** refs;
	}

	class UnitType extends AbsUnitType {
		Unit defaultUnit;
	}

	class ReferenceType {
		prior Integer exponent;
		prior no-view UnitType ref;
	}
	class Reference {
		ReferenceType type;
		Integer exponent;
		Unit ref;
	}
	
	class Conversion {
		// from und to sind Oracle-Schluesselwoerter.
		prior no-view one-to-one (myConversion) Unit source;
		prior Function myFunction;

		Quantity convert(Fraction amount);
		Quantity convertInverse(Fraction amount);
	}

	class Function {
		prior Fraction factor;
		prior Fraction constant;
		//indexed String name; factor*x+constant
		Fraction execute(Fraction amount);
		Fraction executeInverse(Fraction amount);
	}

	class FractionWrapper {
		Fraction fraction;
	}


	/*
	* Manager
	*/
	singleton UnitTypeManager {
		AbsUnitType ** unitTypes;
		no-view derived UnitType** atomicUnitTypes;
		AbsUnit ** units;
	
		/* Operationen fuer Typebene */
		active void createUnitType(String name) throws DoubleDefinitionException;
		active void createCompUnitType(String name) throws DoubleDefinitionException;
		active void removeUnitType(AbsUnitType type);
		active void setDefaultUnit(UnitType type, Unit unit);
		active CompUnitType addReferenceType(String name, AbsUnitType unitType, UnitType referenceUnitType, Integer exponent) 
			throws DoubleDefinitionException;

		/* Operationen fuer Exemplarebene */
		active void createUnit(String name, UnitType type) throws DoubleDefinitionException;
		active void createCompUnit(String name, CompUnitType type) throws DoubleDefinitionException;
		active void removeUnit(AbsUnit unit);
		active CompUnit addReference(String name, AbsUnit unit, Unit referenceUnit, Integer exponent) throws DoubleDefinitionException;
		active void setConversion(Unit unit, Fraction factor, Fraction constant) throws ConsistencyException;
	}

	singleton QuantityManager {
		AbsQuantity ** quantities;
		active Quantity createQuantity(AbsUnit unit, Fraction amount);
		active void convertToDefault(Quantity quantity);
		active void convert(Quantity quantity, AbsUnit unit);
	}

	/*Jeder Bruch nur einmal vorhanden*/
	singleton FractionManager {
		FractionWrapper **String** managedFractions;
		Fraction getFraction(String key) throws NotFoundException;
		active void addFraction(String key, Fraction newFraction) throws DoubleDefinitionException;
	}

	singleton FunctionManager {
		Function** functions;
	}
}

part abstractOperation {

/*** MANAGER ***/
singleton AssociationManager {
	Association ** associations;
	Hierarchy** hierarchies;

active void createAssociation(MType source, MType target, String name) throws DoubleDefinitionException;
active void removeAssociation(Association a) throws CycleException, ConsistencyException;
active void createHierarchy(Association a, String name) throws CycleException, DoubleDefinitionException;

active void addAssociation(Hierarchy h, Association a) throws DoubleDefinitionException, CycleException;
active void removeAssoFrmHier(Hierarchy h, Association a) throws CycleException, NotAvailableException;
}

singleton OperationManager {
	Operation ** operations; // TODO: Typunterscheidung (spezialisierung static/nonstatic & constants)
	derived Operation** staticOperations;
	derived Operation** constants;
	FormalParameter ** formalParameters;

active void createConstant(String name, MType target) throws DoubleDefinitionException;
active void createStaticOp(String name, MType target, FormalParameter** fp) throws DoubleDefinitionException;
active void createOperation(MType source, MType target, String name, FormalParameter** fp) throws DoubleDefinitionException;
active void createVoidOperation(MType source, String name, FormalParameter** fp) throws DoubleDefinitionException;
active void createFp(String name, MType ofType) throws DoubleDefinitionException;

active void addFp(Operation op, FormalParameter fp) throws DoubleDefinitionException;
active void addMultipleFp(Operation op, FormalParameter** fp) throws DoubleDefinitionException;
active void removeFpFromOp(Operation op, FormalParameter fp) throws ConsistencyException;
active void removeFp(FormalParameter fp) throws ConsistencyException;
active void removeOperation(Operation op) throws ConsistencyException;
}

class FormalParameter {
    prior MType ofType;
    indexed prior String name;	
}

abstract class AbsOperation@@AbstractOperation {
    indexed prior String name;
    prior symmetric MType source;
    prior MType target;
    FormalParameter ** parameters;
}

class Association extends AbsOperation {
	symmetric(associations) Hierarchy** hierarchies; 

	MBoolean isObservation();
}

class Operation extends AbsOperation {
	MBoolean isStatic();
}


class Hierarchy {
	prior indexed String name;
}

}

part messageOrLink {

singleton MessageManager{
Message** messages;

active void createMessage(Operation type, MObject source, MObject target, ActualParameter** ap) throws DoubleDefinitionException, ConsistencyException;
active void createVoidMessage(Operation type, MObject source, ActualParameter** ap) throws DoubleDefinitionException, ConsistencyException;
active void createConst(Operation type, String name, MObject target) throws DoubleDefinitionException, ConsistencyException;
active void createStaticMessage(Operation type, String name, MObject target, ActualParameter** ap) throws DoubleDefinitionException, ConsistencyException;
active void removeMessage(Message m);
}

singleton LinkManager {
Link** links;

active void createLink(Association type, MObject source, MObject target) throws ConsistencyException, CycleException;
active void removeLink(Link link);
}

abstract class MessageOrLink {
    prior symmetric MObject source;
    prior symmetric MObject target;
}

// TODO: Was ist mit statische Methoden und Methoden die void zurueck geben sollen? Source/Target 0..1? Eventuell noch mal spezialisieren
class Message extends MessageOrLink {
   prior symmetric Operation type;
	ActualParameter** actualParameters;
}

class ActualParameter {
    prior symmetric FormalParameter type;
    prior MObject value;
}

class Link extends MessageOrLink {
    prior symmetric Association type;
}
}


part basic {
	/* Boolean */
	string-factory abstract class MBoolean(MTrue@@true, MFalse@@false){
		extern boolean toBoolean();	
		MBoolean invert();
	}
}


part measurement {

singleton MeasurementTypeManager##MsrmntTpMng {
	MMeasurementType** measurementTypes;
	active void createMeasurementType(String name, MType type, UnitType unitType);
}

singleton AccountTypeManager {
	MAccountType** accountTypes;
	active void createAccountType(String name, MType type, UnitType unitType);
}

singleton AccountManager {
	Account** accounts;
	active void createAccount(String name, MAccountType type, MObject object);
}

abstract class MQuantiObjectType@@QuantifiedObjectType {
	prior MType type;
	prior AbsUnitType unitType;
}

class MMeasurementType@@MeasurementType extends MQuantiObjectType {
}


class MAccountType@@AccountType extends MQuantiObjectType {
	MAccountType** subAccountTypes hierarchy MAccountTypeHierarchy;
	active void addSubAccountType##addSbAccTyp(MAccountType accountType) throws CycleException;
}
hierarchy MAccountTypeHierarchy##MAccTypeHie;

abstract class QuantifObject@@QuantifiedObject {
	symmetric prior MObject object;
	active AbsQuantity aggregate(AggregationStrategy strategy) throws NotComputableException;
}

class Measurement extends QuantifObject {
	prior MMeasurementType type;
	// TODO: Eventuell erst spaeter, wenn der Type feststeht, die Quantitaet setzen?
	prior AbsQuantity quantity;
}

class Account extends QuantifObject {
	prior MAccountType type;
	Account** subAccounts hierarchy AccountHierarchy;
	Measurement** entries;
	active void addSubAccount(Account account) throws CycleException;
	active void addEntry(Measurement measurement) throws ConsistencyException;
}
hierarchy AccountHierarchy##AccountHie;

interface AggregationStrategy##AggrStrtgy {
	AbsQuantity aggregateMeasurements##aggrtMsmnt(AbsQuantity neutralElement, Measurement** measurements) throws NotComputableException;
}

class MinStrategy implements AggregationStrategy {}
class MaxStrategy implements AggregationStrategy {}
class AvgStrategy implements AggregationStrategy {}
class SumStrategy implements AggregationStrategy {}

}

part naming {
	class Name {
		prior symmetric (possibleNames) MAtomicType fromType;
		prior NameScheme nameScheme;
	}
	
	class NameInstance {
		prior Name type;
		prior symmetric(names) MObject fromObject;
		prior NameSchemeInstance nameScheme;
	}


	class NameScheme {
		prior String regExpPattern;
		prior indexed String name;	
		prior MBoolean isIterable;

		MBoolean match(String name);
	}


	class NameSchemeInstance##NSInst {
		prior String name;
		prior symmetric (names) NameScheme type;
	}
	

	singleton NameSchemeManager {
		NameScheme ** schemes@@Schemata;
		Name ** names@@Zuordnungen;
		
		active Name assignType(NameScheme scheme, MAtomicType type);
		active NameScheme createNameScheme(String name, String regExpPattern, MBoolean isIterable);
		active void assignName(MObject object, Name name, String value) throws PatternNotMatchException, ConsistencyException;
	}

}


/*** EXCEPTIONS ***/
exception PatternNotMatchException{}
exception DoubleDefinitionException{}
exception ConsistencyException{}
exception DeletedException extends ConsistencyException {}
exception WrongSubTypeAspectException{}
exception EmptyTypeException{}
exception NotAvailableException{}
exception NotFoundException{}
exception NotFinalizedException{}
exception ExponentMatchingException{}
exception NotComputableException{}

}