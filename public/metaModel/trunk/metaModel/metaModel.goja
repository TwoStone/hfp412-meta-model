model metaModel{


/*** SERVER ***/

server Server {
	/* TypeManager */
	derived TypeManager typeManager;

	derived QuantityManager quantityManager;
	derived UnitTypeManager unitTypeManager;
	derived ConversionManager conversionManager;
	derived FractionManager fractionManager;

	/* AtomicType */
	void createSubType@@Untertyp_anlegen(MAtomicType superType, String typeName@@Name, MBoolean singletonType, MBoolean abstractType);
	void addSubType@@Bestehenden_Typ_unterordnen(MAtomicType superType, MAtomicType subType@@Untertyp{typeManager;atomicTypes});

	/* AspectManager */
	derived AspectManager aspectManager;
	void createAspect@@Aspekt_anlegen(AspectManager aspectManager, String aspectName@@Name) throws DoubleDefinitionException;

	/* Aspect */
	void createAtomicType@@Atomaren_Typ_anlegen(MAspect parent, String typeName@@Name, MBoolean singletonType, MBoolean abstractType);

	/* Associations */
	derived AssociationManager associationManager;
	void createAssociation(AssociationManager manager, String name, MType source, MType target);
	void createAssociationFrom(MType source, String name, MType target);
	void createAssociationTo(MType target, String name, MType source);
	void createHierarchy(String name);
	void addToHierarchy(MAssociation association, MAHierarchy theHierarchy);
	void addAssociations(MAHierarchy theHierarchy, MAssociation association);
	
	void createUnitType@@Create_unit_type(UnitTypeManager unitTypeManager, String name);
	void createCompUnitType@@Create_compound_unit_type(UnitTypeManager unitTypeManager, String name);
	void addReferenceType(CompUnitType compUnitType, UnitType unitType, Integer exponent);
	void finishModeling@@Publish(CompUnitType compUnitType);

	void createUnit@@Create_unit(AbsUnitType type, String name);

	void createQuantity@@Create_quantity(AbsUnit unit, Fraction f);

}

part quantity {

	abstract class AbsQuantity {
	
		AbsQuantity add(AbsQuantity summand);
		AbsQuantity sub(AbsQuantity minuend);
		AbsQuantity mul(AbsQuantity factor);
		AbsQuantity div(AbsQuantity divisor);
	}

	class Quantity extends AbsQuantity {
		Fraction amount;
		Unit unit;
	}

	class CompoundQuantity extends AbsQuantity {
		Quantity ** parts; // +
	}

	abstract class AbsUnit {
		no-view prior AbsUnitType type; // 1
		indexed prior String name;
	}

	class CompUnit extends AbsUnit {
		Reference ** refs;
		no-view MBoolean isFinal;
		void finishModeling() throws AlreadyFinalizedException, ExponentMatchingException;
		MBoolean isFinal();
		
		/* Pr?ft, ob Exponenten der Exemplarebene mit Typebene ?bereinstimmen*/
		void checkExponents() throws ExponentMatchingException;
	}
	class Unit extends AbsUnit {	}

	abstract class AbsUnitType {
		AbsUnit defaultUnit; // 0..1
		indexed prior String name;
	}

	class CompUnitType extends AbsUnitType {
		ReferenceType ** refs;	
		no-view MBoolean isFinal;
		void finishModeling() throws AlreadyFinalizedException;
		MBoolean isFinal();
	}

	class UnitType extends AbsUnitType {}

	class ReferenceType {
		Integer exponent;
		no-view UnitType ref;
	}
	class Reference {
		ReferenceType type;
		Integer exponent;
		Unit ref;
	}
	
	class Conversion {
		// from und to sind Oracle-Schluesselwoerter.
		prior one-to-one (myConversion) Unit source;
		prior UnitType type;
		Function myFunction;

		Quantity convert(Fraction amount);
		Quantity convertInverse(Fraction amount);
	}

	class Function {
		prior Fraction factor;
		prior Fraction constant;
		//Wie muss eine Function aussehen? --> y=a*x+b	
		Fraction execute(Fraction amount);
		Fraction executeInverse(Fraction amount);
	}


/*
* Manager
*/
singleton UnitTypeManager {
	AbsUnitType ** unitTypes;
	AbsUnit ** units;

	/* Operationen f?r Typebene */
	active void createUnitType(String name) throws DoubleDefinitionException;
	active void createCompUnitType(String name) throws DoubleDefinitionException;
	active void finishModeling(CompUnitType compUnitType) throws AlreadyFinalizedException;
	active void addDefaultUnit(AbsUnitType type, AbsUnit unit);
	active void addReferenceType(CompUnitType compUnitType, UnitType unitType, Integer exponent) 
		throws DoubleDefinitionException, AlreadyFinalizedException;

	/* Operationen f?r Exemplarebene */
	active void createUnit(String name, UnitType type) throws DoubleDefinitionException;
	active void createCompUnit(String name, CompUnitType type) throws DoubleDefinitionException, NotFinalizedException;

	}

	singleton QuantityManager {
		AbsQuantity ** quantities;
		active void createQuantity(AbsUnit unit, Fraction amount) throws NotFinalizedException;
	}

	singleton ConversionManager {
		Conversion ** conversions;
		active void createConversion(Unit unit, Fraction factor, Fraction constant);
	}

	/*Jeder Bruch nur einmal vorhanden*/
	singleton FractionManager {
	//	Fraction ** fractions;
	}
}


/*** MANAGER ***/

singleton AspectManager {
	MAspect** aspects;
	active void createAspect(String name) throws DoubleDefinitionException;
}

singleton TypeManager {
	MAtomicType** atomicTypes;
	MProductType** productTypes;
	MSumType** sumTypes;
	MType**MSumType** allTypes;

	active void createAtomicType(MAspect aspect, String name, MBoolean singletonType, MBoolean abstractType) throws DoubleDefinitionException, ConsistencyException;
	active void createSubType(MAtomicType superType, String name, MBoolean singletonType, MBoolean abstractType) throws CycleException, WrongSubTypeAspectException, DoubleDefinitionException, ConsistencyException;
	active void addSubType(MAtomicType superType, MAtomicType typeunder) throws CycleException, WrongSubTypeAspectException;
}

singleton AssociationManager {
	MAssociation ** associations;
	MAHierarchy** hierarchies;
	
	active void createHierarchy(String name) throws DoubleDefinitionException;
	active void createAssociation(String name, MType source, MType target) throws DoubleDefinitionException;
	active void addToHierarchy(MAssociation association, MAHierarchy theHierarchy);

}


/*** TYPE ***/

class MAspect {
	prior indexed String name; 
}

interface MType@@Type {
	String fetchName();
 	MSumType fetchDisjunctiveNormalform();
	MAssociation** fetchAssociations();
	MBoolean allObjectsOfTypeAreSingleton();
	MBoolean isSingleton();
	MBoolean isAbstract();
	MBoolean isLessOrEqual(MType otherType); 
	MBoolean isStructuralEqual(MType otherType); 
	MBoolean contains(MType otherType);
	MSumType transientAddAddend(MType addend) throws ConsistencyException;
	MProductType transientAddFactor(MType factor) throws ConsistencyException;
	 
}

hierarchy MAtomicTypeHierarchy##MATypeHier;

class MAtomicType@@AtomicType implements MType {
	prior indexed String name;
	prior MBoolean singletonType;
	prior MBoolean abstractType;
	no-view prior symmetric(types) MAspect aspect;
	symmetric(subTypes) no-view MAtomicType superType hierarchy MAtomicTypeHierarchy;
	
	void addSubType(MAtomicType typeunder) throws CycleException, WrongSubTypeAspectException;
	MBoolean transitiveHasConcreteSubtype();
}

hierarchy MComplexTypeHierarchy##MCTypeHier;

abstract class MComplexType@@ComplexType implements MType {
	MType** containedTypes hierarchy MComplexTypeHierarchy;
	derived String TypeLinkOperator;
		
}

abstract class MBoolean(MTrue, MFalse){
	extern boolean toBoolean();	
	MBoolean createFromBoolean(extern boolean bool);
	MBoolean invert();
}

class MProductType@@ProductType extends MComplexType {}

singleton MEmptyProduct@@EmptyProduct extends MProductType{
}


class MSumType@@SumType extends MComplexType {


	
	/* TODO: Leere Summen!? oh-oh! */
}
singleton MEmptySum@@EmptySum extends MSumType{
}


/** ASSOCIATIONS **/

class MAssociation {
	prior String name;
	prior MType source;
	prior MType target;
	symmetric(associations) MAHierarchy** hierarchies; 
}
class MAHierarchy {
	prior indexed String name;
}

/*** EXCEPTIONS ***/

exception DoubleDefinitionException{}
exception ConsistencyException{}
exception WrongSubTypeAspectException{}


exception AlreadyFinalizedException{}
exception NotFinalizedException{}
exception ExponentMatchingException{}

}