model metaModel{


/*** SERVER ***/

server Server {
	/**** Manager ****/
	derived AspectManager aspectManager;
	derived TypeManager typeManager;
	derived QuantityManager quantityManager;
	derived UnitTypeManager unitTypeManager;
	derived ConversionManager conversionManager;
	derived FractionManager fractionManager;

	derived MeasurementTypeManager measurementTypeManager;
	derived AccountTypeManager accountTypeManager;
	derived AccountManager accountManager;

	/** Type **/
	void createAspect(AspectManager aspectManager, String name);
	void createAtomicRootType(MAspect aspect, String typeName, MBoolean singletonType, MBoolean abstractType);
	void createAtomicSubType(MAtomicType superType, String typeName, MBoolean singletonType, MBoolean abstractType);
	//	void addSubType@@Bestehenden_Typ_unterordnen(MAtomicType superType, MAtomicType subType@@Untertyp{typeManager;atomicTypes});

	/** Associations **/
	derived AssociationManager associationManager;
	void createAssociation(AssociationManager manager, String name, MType source, MType target);
	void createAssociationFrom(MType source, String name, MType target);
	void createAssociationTo(MType target, String name, MType source);
	void createHierarchy(String name);
	void addToHierarchy(MAssociation association, MAHierarchy theHierarchy);
	void addAssociations(MAHierarchy theHierarchy, MAssociation association);
	
	/** Quantity/Unit **/
	void createUnitType@@Create_unit_type(UnitTypeManager unitTypeManager, String name);
	void createCompUnitType@@Create_compound_unit_type(UnitTypeManager unitTypeManager, String name);
	void addReferenceType(CompUnitType compUnitType, UnitType unitType {unitTypeManager;atomicUnitTypes}, Integer exponent);
	void finishModeling@@Publish(CompUnitType compUnitType);
	void createUnit@@Create_unit(AbsUnitType type, String name);
	void createQuantity@@Create_quantity(AbsUnit unit, Fraction f);

	/** Measurement/Account **/
	void createMeasurementType@@Messungstyp_anlegen(MeasurementTypeManager measurementTypeManager, String name, MType type {typeManager;types}, UnitType unitType {unitTypeManager;atomicUnitTypes});
	void createAccountType@@Kontotyp_anlegen(AccountTypeManager accountTypeManager, String name, MType type {typeManager;types}, UnitType unitType {unitTypeManager;atomicUnitTypes});
	void createAccount@@Konto_anlegen(AccountManager accountManager, String name, MAccountType type {accountTypeManager;accountTypes}, InstanceObject object);
}



part typeSystem {
	
	/* Abstrakte Typen */
	abstract class MType@@Type {
		abstract String fetchName();
		abstract MBoolean isLessOrEqual();
		abstract MBoolean isSingleton();
		abstract MBoolean isAbstract();
		abstract MBoolean isStructuralEquivalant(MType other);  	/*		
			MSumType fetchDisjunctiveNormalform();
			MAssociation** fetchAssociations();
			MBoolean allObjectsOfTypeAreSingleton();

			MBoolean isLessOrEqual(MType otherType); 
			MBoolean isStructuralEqual(MType otherType); 
			MBoolean contains(MType otherType);
			*/
	}

	/* Aspekte */
	class MAspect@@Aspect {
		prior indexed String name; 
	}
	
	/* Atomare Typen */
	class MAtomicType@@AtomicType extends MType {
		prior indexed String name;
		prior MBoolean singletonType;
		prior MBoolean abstractType;
		no-view prior symmetric(types) MAspect aspect;
		no-view symmetric(subTypes) MAtomicType superType hierarchy MAtomicTypeHierarchy;
			/*
			void addSubType(MAtomicType typeunder) throws CycleException, WrongSubTypeAspectException;
			MBoolean transitiveHasConcreteSubtype();
			*/
	}
	
	/* Komplexe Typen*/
	abstract class MComplexType@@ComplexType extends MType {
		MType** containedTypes hierarchy MComplexTypeHierarchy;
		abstract String fetchTypeLinkOperator();
	}
	
	/* ++ Summentypen ++ */
	abstract class MAbstractSumType##MAbstrSum@@AbstractSumType extends MComplexType {
	}
	
	singleton MEmptySumType@@EmptySumType extends MAbstractSumType {
	}
	
	class MSumType@@SumType extends MAbstractSumType {
	}

	/* ** Produkttypen ** */
	class MAbstractProductType##MAbstrProd@@AbstractProductType extends MComplexType {
	}

	singleton MEmptyProduct@@EmptyProductType extends MAbstractProductType{
	}
	
	class MProductType@@ProductType extends MAbstractProductType {
	}


	/*** MANAGER ***/
	/* Manager  for Aspects */
	singleton AspectManager {
		MAspect** aspects;
		active MAspect createAspect(String name) throws ConsistencyException;
	}
	/* Manager for Types */
	singleton TypeManager {
		MType** types;
		
		active MAtomicType createAtomicRootType(MAspect aspect, String name, MBoolean singletonType, MBoolean abstractType) 
			throws ConsistencyException;
		active MAtomicType createAtomicSubType(MAtomicType superType, String name, MBoolean singletonType, MBoolean abstractType) 
			throws ConsistencyException;
		active MAbstractSumType createSumType(MType** addends) throws ConsistencyException;
		active MAbstractProductType createProductType(MType** factors) throws ConsistencyException;

		active void addSubType(MAtomicType superType, MAtomicType subType) throws CycleException, ConsistencyException;
	}
	
	/*** HIERARCHIES ***/
	/* Partielle Ordnung "<=" auf atomaren Typen */
	hierarchy MAtomicTypeHierarchy##MATypeHier;
	/* Partielle Ordnung "enthalten sein" auf allen Typen */
	hierarchy MComplexTypeHierarchy##MCTypeHier;
}





part quantity {

	abstract class AbsQuantity {
	
		AbsQuantity add(AbsQuantity summand);
		AbsQuantity sub(AbsQuantity minuend);
		AbsQuantity mul(AbsQuantity factor);
		AbsQuantity div(AbsQuantity divisor);
	}

	class Quantity extends AbsQuantity {
		Fraction amount;
		Unit unit;
	}

	class CompoundQuantity extends AbsQuantity {
		Quantity ** parts; // +
	}

	abstract class AbsUnit {
		no-view prior AbsUnitType type; // 1
		indexed prior String name;
	}

	class CompUnit extends AbsUnit {
		Reference ** refs;
		no-view MBoolean isFinal;
		void finishModeling() throws AlreadyFinalizedException, ExponentMatchingException;
		MBoolean isFinal();
		
		/* Pr?ft, ob Exponenten der Exemplarebene mit Typebene ?bereinstimmen*/
		void checkExponents() throws ExponentMatchingException;
	}
	class Unit extends AbsUnit {	}

	abstract class AbsUnitType {
		AbsUnit defaultUnit; // 0..1
		indexed prior String name;
	}

	class CompUnitType extends AbsUnitType {
		ReferenceType ** refs;	
		no-view MBoolean isFinal;
		void finishModeling() throws AlreadyFinalizedException;
		MBoolean isFinal();
	}

	class UnitType extends AbsUnitType {}

	class ReferenceType {
		Integer exponent;
		no-view UnitType ref;
	}
	class Reference {
		ReferenceType type;
		Integer exponent;
		Unit ref;
	}
	
	class Conversion {
		// from und to sind Oracle-Schluesselwoerter.
		prior one-to-one (myConversion) Unit source;
		prior UnitType type;
		Function myFunction;

		Quantity convert(Fraction amount);
		Quantity convertInverse(Fraction amount);
	}

	class Function {
		prior Fraction factor;
		prior Fraction constant;
		//Wie muss eine Function aussehen? --> y=a*x+b	
		Fraction execute(Fraction amount);
		Fraction executeInverse(Fraction amount);
	}


/*
* Manager
*/
singleton UnitTypeManager {
	AbsUnitType ** unitTypes;
	derived UnitType** atomicUnitTypes;
	AbsUnit ** units;

	/* Operationen f?r Typebene */
	active void createUnitType(String name) throws DoubleDefinitionException;
	active void createCompUnitType(String name) throws DoubleDefinitionException;
	active void finishModeling(CompUnitType compUnitType) throws AlreadyFinalizedException;
	active void addDefaultUnit(AbsUnitType type, AbsUnit unit);
	active void addReferenceType(CompUnitType compUnitType, UnitType unitType, Integer exponent) 
		throws DoubleDefinitionException, AlreadyFinalizedException;

	/* Operationen f?r Exemplarebene */
	active void createUnit(String name, UnitType type) throws DoubleDefinitionException;
	active void createCompUnit(String name, CompUnitType type) throws DoubleDefinitionException, NotFinalizedException;

	}

	singleton QuantityManager {
		AbsQuantity ** quantities;
		active void createQuantity(AbsUnit unit, Fraction amount) throws NotFinalizedException;
	}

	singleton ConversionManager {
		Conversion ** conversions;
		active void createConversion(Unit unit, Fraction factor, Fraction constant);
	}

	/*Jeder Bruch nur einmal vorhanden*/
	singleton FractionManager {
	//	Fraction ** fractions;
	}
}


/*** MANAGER ***/




singleton AssociationManager {
	MAssociation ** associations;
	MAHierarchy** hierarchies;
	
	active void createHierarchy(String name) throws DoubleDefinitionException;
	active void createAssociation(String name, MType source, MType target) throws DoubleDefinitionException;
	active void addToHierarchy(MAssociation association, MAHierarchy theHierarchy);

}


class InstanceObject {
	prior MAtomicType type;
}

/** ASSOCIATIONS **/
class MFormalParameter@@FormalParameter {
    prior MType ofType;
    indexed prior String name;
}

class ActualParameter {
    prior MFormalParameter type;
    prior InstanceObject value;
}

abstract class MAbsOperation@@AbstractOperation {
    indexed prior String name;
    prior MType source;
    prior MType target;
    MFormalParameter ** parameters;
}

class MAssociation {
	prior String name;
	prior MType source;
	prior MType target;
	symmetric(associations) MAHierarchy** hierarchies; 

	MBoolean isObservation();
}

class MOperation extends MAbsOperation {
}

abstract class MessageOrLink {
    prior InstanceObject source;
    prior InstanceObject target;
}

// TODO: Was ist mit statische Methoden und Methoden die void zurueck geben sollen? Source/Target 0..1? Eventuell noch mal spezialisieren
class Message extends MessageOrLink {
    prior MOperation type;
}

class Link extends MessageOrLink {
    prior MAssociation type;
}


class MAHierarchy {
	prior indexed String name;
}


part basic {
	/* Boolean */
	abstract class MBoolean(MTrue, MFalse){
		extern boolean toBoolean();	
		MBoolean invert();
	}
}


part measurement {

singleton MeasurementTypeManager##MsrmntTpMng {
	MMeasurementType** measurementTypes;
	active void createMeasurementType(String name, MType type, UnitType unitType);
}

singleton AccountTypeManager {
	MAccountType** accountTypes;
	active void createAccountType(String name, MType type, UnitType unitType);
}

singleton AccountManager {
	Account** accounts;
	active void createAccount(String name, MAccountType type, InstanceObject object);
}

abstract class MQuantiObjectType@@QuantifiedObjectType {
	prior MType type;
	prior AbsUnitType unitType;
}

class MMeasurementType@@MeasurementType extends MQuantiObjectType {
}

hierarchy MAccountTypeHierarchy##MAccTypeHie;
class MAccountType@@AccountType extends MQuantiObjectType {
	MAccountType** subAccountTypes hierarchy MAccountTypeHierarchy;
}


abstract class QuantifObject@@QuantifiedObject {
	prior InstanceObject object;
	// TODO: aggregate(s:AggregationStrategy) : Quantity
}

class Measurement extends QuantifObject {
	prior MMeasurementType type;
	// TODO: Eventuell erst spaeter, wenn der Type feststeht, die Quantitaet setzen?
	prior AbsQuantity quantity;
}

hierarchy AccountHierarchy##AccountHie;
class Account extends QuantifObject {
	prior MAccountType type;
	Account** subAccounts hierarchy AccountHierarchy;
	Measurement** entries;
}

}


/*** EXCEPTIONS ***/

exception DoubleDefinitionException{}
exception ConsistencyException{}
exception WrongSubTypeAspectException{}


exception AlreadyFinalizedException{}
exception NotFinalizedException{}
exception ExponentMatchingException{}

}