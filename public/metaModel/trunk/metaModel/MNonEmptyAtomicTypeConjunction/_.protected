
	@Override
	public SearchListRoot<? extends PersistentMType> fetchContainedTypes() throws PersistenceException {
		return getThis().getFactors();
	}

	@Override
	public PersistentMAtomicTypeConjunction transientMultiply(PersistentMAtomicTypeConjunction other)
			throws PersistenceException {
		return other.accept(new MAtomicTypeConjunctionReturnVisitor<PersistentMAtomicTypeConjunction>() {

			@Override
			public PersistentMAtomicTypeConjunction handleMNonEmptyAtomicTypeConjunction(
					PersistentMNonEmptyAtomicTypeConjunction mNonEmptyAtomicTypeConjunction)
					throws PersistenceException {
				return getThis().transientMultiplyNonEmpty(mNonEmptyAtomicTypeConjunction);
			}

			@Override
			public PersistentMAtomicTypeConjunction handleMEmptyTypeConjunction(
					PersistentMEmptyTypeConjunction mEmptyTypeConjunction) throws PersistenceException {
				return getThis();
			}
		});
	}

	public static PersistentMNonEmptyAtomicTypeConjunction transientCreateNETypeConj(MAtomicTypeSearchList sl)
			throws PersistenceException {
		final PersistentMNonEmptyAtomicTypeConjunction result = MNonEmptyAtomicTypeConjunction
				.createMNonEmptyAtomicTypeConjunction(true);
		sl.applyToAll(new Procdure<PersistentMAtomicType>() {

			@Override
			public void doItTo(PersistentMAtomicType argument) throws PersistenceException {
				try {
					result.getFactors().add(argument);
				} catch (CycleException e) {
					// should not occur
					e.printStackTrace();
				}
			}
		});
		return result;
	}
	