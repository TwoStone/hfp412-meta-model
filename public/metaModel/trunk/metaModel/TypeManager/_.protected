
	private static void checkMAtomicTypeNameAndConsitency(String name, PersistentMBoolean singletonType,
			PersistentMBoolean abstractType) throws PersistenceException, ConsistencyException {
		if (singletonType.toBoolean() && abstractType.toBoolean()) {
			throw new ConsistencyException("Singletons may not be abstract");
		}
		if (name.isEmpty()) {
			throw new ConsistencyException("Atomic-Type must have a non-empty name");
		}
		if (MAtomicType.getMAtomicTypeByName(name).getLength() > 0) {
			throw new ConsistencyException("AtomicType-names must be unique. An AtomicType with name " + name
					+ " is already existing.");
		}
	}

	/*
	 * static ArrayList<PersistentMAtomicTypeProduct> filterAtomicProducts(MTypeSearchList list) throws
	 * PersistenceException { final ArrayList<PersistentMAtomicTypeProduct> result = new
	 * ArrayList<PersistentMAtomicTypeProduct>(); list.applyToAll(new Procdure<PersistentMType>() {
	 * 
	 * @Override public void doItTo(PersistentMType argument) throws PersistenceException { argument.accept(new
	 * MTypeStandardVisitor() {
	 * 
	 * @Override protected void standardHandling(PersistentMType mType) throws PersistenceException { }
	 * 
	 * @Override public void handleMAtomicTypeProduct(PersistentMAtomicTypeProduct mAtomicTypeProduct) throws
	 * PersistenceException { result.add(mAtomicTypeProduct); }
	 * 
	 * }); } }); return result; }
	 * 
	 * private static ArrayList<PersistentMAtomicType> filterAtomicTypes(MTypeSearchList list) throws
	 * PersistenceException { final ArrayList<PersistentMAtomicType> result = new ArrayList<PersistentMAtomicType>();
	 * list.applyToAll(new Procdure<PersistentMType>() {
	 * 
	 * @Override public void doItTo(PersistentMType argument) throws PersistenceException { argument.accept(new
	 * MTypeStandardVisitor() {
	 * 
	 * @Override protected void standardHandling(PersistentMType mType) throws PersistenceException { }
	 * 
	 * @Override public void handleMAtomicType(PersistentMAtomicType mAtomicType) throws PersistenceException {
	 * result.add(mAtomicType); } }); } }); return result; }
	 */

	private PersistentMType getStructuralEquivalentType(final PersistentMType search) throws PersistenceException {
		return getThis().getTypes().findFirst(new Predcate<PersistentMType>() {

			@Override
			public boolean test(PersistentMType argument) throws PersistenceException {
				return search.isStructuralEquivalant(argument).toBoolean();
			}
		});
	}

	private void checkOnlyNonSingletonFactors(MTypeSearchList factors) throws ConsistencyException,
			PersistenceException {
		for (PersistentMType type : Iterables.wrap(factors)) {
			if (type.isSingleton().toBoolean()) {
				throw new ConsistencyException("Die Produktbildung von Singletons ist nicht erlaubt!");
			}
		}
	}

	