
	private static void checkTypeIsAssignable(final PersistentMObject object, final PersistentName name)
			throws PersistenceException, ConsistencyException {
		SearchListRoot<PersistentMAtomicType> fittingTypes = object.getTypes().findAll(
				new Predcate<PersistentMAtomicType>() {

					@Override
					public boolean test(PersistentMAtomicType argument) throws PersistenceException {
						return argument.isLessOrEqual(name.getFromType()).toBoolean();
					}
				});

		if (!fittingTypes.iterator().hasNext()) {
			throw new model.ConsistencyException("Das Objekt kann nicht in diesem Schema benannt werden!");
		}
	}

	private static void checkNameSchemeIsNotPresent(final PersistentMObject object, final PersistentName name)
			throws PersistenceException, ConsistencyException {
		PersistentNameInstance nameWithScheme = object.getNames().findFirst(new Predcate<PersistentNameInstance>() {

			@Override
			public boolean test(PersistentNameInstance argument) throws PersistenceException {
				return argument.getType().equals(name);
			}
		});
		if (nameWithScheme != null) {
			throw new ConsistencyException("Das Objekt hat bereits einen Namen in dem Schema!");
		}
	}

	private static void checkNameIsValid(final PersistentName name, final String value) throws PersistenceException,
			PatternNotMatchException {
		if (!name.getNameScheme().match(value).toBoolean()) {
			throw new PatternNotMatchException("Der angegebene Name entspricht nicht dem Schema!");
		}
	}

	