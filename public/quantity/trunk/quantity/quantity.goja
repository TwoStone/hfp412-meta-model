model quantity {
/*-------------------------------------------------------------------------
	FASSADEN
-------------------------------------------------------------------------*/


	server Server {

		derived QuantityManager quantityManager;
		derived UnitTypeManager unitTypeManager;
		derived ConversionManager conversionManager;
		derived FractionManager fractionManager;

		void createUnitType(String name);
		void createCompUnitType(String name);
		void addReferenceType(CompUnitType compUnitType, UnitType unitType, Integer exponent);
		void finishModeling(CompUnitType compUnitType);
	}

/*-------------------------------------------------------------------------
	MANAGER KLASSEN
-------------------------------------------------------------------------*/

	singleton UnitTypeManager {
		AbsUnitType ** unitTypes;
		AbsUnit ** units;

		/* Operationen für Typebene */
		active void createUnitType(String name) throws DoubleDefinitionException;
		active void createCompUnitType(String name) throws DoubleDefinitionException;
		active void finishModeling(CompUnitType compUnitType) throws AlreadyFinalizedException;
		active void addDefaultUnit(AbsUnitType type, AbsUnit unit);
		active void addReferenceType(CompUnitType compUnitType, UnitType unitType, Integer exponent) 
			throws DoubleDefinitionException, AlreadyFinalizedException;

		/* Operationen für Exemplarebene */
		active void createUnit(UnitType type, String name) throws DoubleDefinitionException;

	}

	singleton QuantityManager {
		AbsQuantity ** quantities;
		active void createQuantity(Unit unit, Fraction amount);
	}

	singleton ConversionManager {
		Conversion ** conversions;
		active void createConversion(Unit unit, Fraction factor, Fraction constant);
	}

	/*Jeder Bruch nur einmal vorhanden*/
	singleton FractionManager {
	//	Fraction ** fractions;
	}

/*-------------------------------------------------------------------------
	MODELL KLASSEN
-------------------------------------------------------------------------*/
	abstract class AbsQuantity {
	
		AbsQuantity add(AbsQuantity summand);
		AbsQuantity sub(AbsQuantity minuend);
		AbsQuantity mul(AbsQuantity factor);
		AbsQuantity div(AbsQuantity divisor);
	}

	class Quantity extends AbsQuantity {
		Fraction amount;
		Unit unit;
	}

	class CompoundQuantity extends AbsQuantity {
		Quantity ** parts; // +
	}

	abstract class AbsUnit {
		prior AbsUnitType type; // 1
		indexed prior String name;
	}

	class CompUnit extends AbsUnit {
		Reference ** refs;
	}
	class Unit extends AbsUnit {	}

	abstract class AbsUnitType {
		AbsUnit defaultUnit; // 0..1
		indexed prior String name;
	}

	class CompUnitType extends AbsUnitType {
		ReferenceType ** refs;	
		BooleanValue isFinal;
		void finishModeling() throws AlreadyFinalizedException;
		BooleanValue isFinal();
	}

	class UnitType extends AbsUnitType {}

	class ReferenceType {
		Integer exponent;
		UnitType ref;
	}
	class Reference {
		ReferenceType type;
		Integer exponent;
		Unit ref;
	}
	
	class Conversion {
		// from und to sind Oracle-Schlüsselwörter.
		prior one-to-one (myConversion) Unit source;
		prior UnitType type;
		Function myFunction;

		Quantity convert(Fraction amount);
		Quantity convertInverse(Fraction amount);
	}

	class Function {
		prior Fraction factor;
		prior Fraction constant;
		//Wie muss eine Function aussehen? --> y=a*x+b	
		Fraction execute(Fraction amount);
		Fraction executeInverse(Fraction amount);
	}

	abstract class BooleanValue {}
	
	final singleton BooleanTrue extends BooleanValue {}
	final singleton BooleanFalse extends BooleanValue {}

/*-------------------------------------------------------------------------
	EXCEPTIONS
-------------------------------------------------------------------------*/
	exception DoubleDefinitionException{}
	exception AlreadyFinalizedException{}

}