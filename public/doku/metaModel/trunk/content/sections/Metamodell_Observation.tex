\subsection{Observations}\label{Observations}
Im Gegensatz zum ursprünglichen Modell haben wir uns nach längerer Diskussion
dazu entschlossen Observations auszulagern. Das soll zum einen der Übersicht
und Transparenz des Modells zu gute kommen und zum anderen, die aufwändige
Handhabung von Singletons für Observations vermeiden.

Ursprünglich handelte es sich fachlich um eine Observation, wenn ein Typ nur aus
Singletons bestand. Dabei stellten sich folgende Fragestellungen, welche die Verwendung
von Observations in der ursprünglichen Variante unnötig verkompliziert
haben:

In der ursprünglichen Modellierung handelte es sich bei einer Observation um eine Assoziation bei der das Ziel auf einen 
Typ zeigte, der nur aus Singletons bestand. Damit dies aber möglich ist, müssen in der Typ-Hierarchie alle Knoten 
abstrakt und alle Blätter Singletons sein. Diese Bedingung muss aber für allgemeine Singletons nicht gelten. Um an dieser 
Stelle eine klare Trennung zu erreichen und die Transparenz des Modells zu erhöhen, wurden Observations als eigener Modell-Abschnitt ausgelagert.

\img[width=\relWidth{1}]{observation/observation.png}{Ausschnitt Observations}{img_observations}

Observations werden auf Modellebene durch die Klassen \emph{Enum} und \emph{ObservationType} repräsentiert. 
Wie man daran bereits erkennen kann, werden Observations mithilfe von Enumerationen interpretiert. 
Dass bedeutet dass jeder konkreten Observation ein Wert einer Enumeration zugewiesen wird. 
Die Klasse \emph{Enum} typisiert dabei die Enumeration. 

Ein Beispiel für einen Enum Typ ist \qq{Blutgruppe}. Die Klasse ObservationType stellt auf Modellebene die 
Typisierung einer Observation dar. Dabei haben wir festgelegt, dass jede Observation genau einer Enumeration 
und genau einem Typen zugeordnet sein muss. Man kann sich an dieser Stelle nun fragen, warum nicht mehrere Typen 
zugeordnet werden können. Der Grund dafür ist, dass wir dies bereits über komplexe Typen definieren können und somit 
an dieser Stelle darauf verzichtet werden kann.

Auf der Instanzebene werden Observations mit den Klassen \emph{EnumValue} und \emph{Observation} abgebildet. 
Die Klasse \emph{EnumValue} spiegelt dabei einen konkreten Enumeration Wert (z. B. Blutgruppe A) wieder, 
wobei die Zuordnung zur Enumeration über die theType Assoziation erfolgt. 
Die Klasse Observation definiert eine konkrete Observation. 
Sie ist typisiert in einem ObservationType und hat jeweils eine zu-Eins Assoziation zu einem konkreten Enumeration Wert 
und einem konkreten Objekt.

Es ergeben sich die folgenden Konsistenzbedingungen:
\begin{itemize}
  \item Enum Objekte dürfen nur gelöscht werden wenn weder EnumValue noch ObservationType Objekte diese referenzieren.
  \item ObservationType Objekte dürfen nur gelöscht werden, wenn es keine Ausprägungen auf der Instanzebene gibt (Observation).
  \item Der Name von EnumValue Objekte muss innerhalb des gleichen Typs (Enum) eindeutig sein. Somit soll verhindert werden, dass beispielsweise 2x der Wert \qq{Blutgruppe A} einer Enumeration \qq{Blutgruppe} zugewiesen werden kann.
\end{itemize}

Für die Observation Objekte müssen folgende Bedingungen gelten:
\begin{equation}\forall o \in Observation: o.theType.enumType = o.enumValue.theType
\end{equation}
\begin{equation}\forall o \in Observation: o.theObsObject.type \leq o.theType.theType
\end{equation}

Für die Erzeugung, das Löschen und die Verwaltung von Observations wurden die folgenden Manager definiert:
\begin{description}
\item[EnumerationManager] Erzeugen und Löschen von Enumerations.
\item[ObsTypeManager] Erzeugen und Löschen von Observation Types.
\item[ObservationManager] Erzeugen und Löschen von Observations.
\item[EnumValueManager] Erzeugen und Löschen von Enumeration Werten.
\end{description}
