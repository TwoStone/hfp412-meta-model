\subsection{Observations}\label{Observations}
In der ursprünglichen Modellierung handelte es sich bei einer Observation um eine Assoziation bei der das Ziel auf einen 
Typ zeigte, der nur aus Singletons bestand. Damit dies aber möglich ist, müssen in der Typ-Hierarchie alle Knoten 
abstrakt und alle Blätter Singletons sein. Diese Bedingung muss aber für allgemeine Singletons nicht gelten. Um an dieser 
Stelle eine klare Trennung zu erreichen und die Transparenz des Modells zu erhöhen, wurden Observations als eigener Modell-Abschnitt ausgelagert.

\img[width=\relWidth{1}]{observation/observation.pdf}{Ausschnitt Observations}{img_observations}

Observations werden auf Modellebene durch die Klassen \term{Enum} und \term{ObservationType} repräsentiert. 
Zum Interpretieren der Observations dienen Enumerationen. Das bedeutet, dass jeder konkreten Observation
ein Wert einer Enumeration zugewiesen wird. Die Klasse \term{Enum} typisiert dabei die Enumeration. 
Im aktuellen Entwicklungsstand ist es nicht vorgesehen Enumerations zu spezialisieren.

Ein Beispiel für einen Enum Typ ist \qq{Blutgruppe}. Die Klasse \term{ObservationType} stellt auf Modellebene die 
Typisierung einer \term{Observation} dar. Dabei haben wir festgelegt, dass jede Observation genau einer Enumeration 
und genau einem Typen zugeordnet sein muss. Man kann sich an dieser Stelle nun fragen, warum nicht mehrere Typen 
zugeordnet werden können. Der Grund dafür ist, dass wir dies bereits über komplexe Typen definieren können und somit 
an dieser Stelle darauf verzichtet werden kann.

Auf der Instanzebene werden Observations mit den Klassen \term{EnumValue} term \term{Observation} abgebildet. 
Die Klasse \term{EnumValue} spiegelt dabei einen konkreten Enumeration Wert (z. B. Blutgruppe A) wieder, 
wobei die Zuordnung zur Enumeration über die theType Assoziation erfolgt. Die Klasse \term{Observation} definiert eine konkrete Observation. 
Sie ist typisiert in einem \term{ObservationType} und hat jeweils eine zu-Eins Assoziation zu einem konkreten Enumeration Wert sowie einem konkreten Objekt.

Es ergeben sich die folgenden Konsistenzbedingungen:
\begin{itemize}
  \item Enum Objekte dürfen nur gelöscht werden wenn weder EnumValue noch ObservationType Objekte diese referenzieren.
  \item ObservationType Objekte dürfen nur gelöscht werden, wenn es keine Ausprägungen auf der Instanzebene gibt (Observation).
  \item Der Name von EnumValue Objekte muss innerhalb des gleichen Typs (Enum) eindeutig sein. Somit soll verhindert werden, dass beispielsweise 2x der Wert \qq{Blutgruppe A} einer Enumeration \qq{Blutgruppe} zugewiesen werden kann.
\end{itemize}

Für die Observation Objekte müssen folgende Bedingungen gelten:
\begin{equation}\forall o \in Observation: o.theType.enumType = o.enumValue.theType
\end{equation}
\begin{equation}\forall o \in Observation: o.theObsObject.type \leq o.theType.theType
\end{equation}

Für die Erzeugung, das Löschen und die Verwaltung von Observations wurden die folgenden Manager definiert:
\begin{description}
\item[EnumerationManager] Erzeugen und Löschen von Enumerations.
\item[ObsTypeManager] Erzeugen und Löschen von Observation Types.
\item[ObservationManager] Erzeugen und Löschen von Observations.
\item[EnumValueManager] Erzeugen und Löschen von Enumeration Werten.
\end{description}
