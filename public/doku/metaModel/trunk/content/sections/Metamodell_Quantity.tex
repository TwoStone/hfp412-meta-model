\subsection{Quantity}
Die Klasse Quantity dient zur Angabe von einheitenbehafteten Werten. Jede Einheit ist dabei in einem Einheitentyp typisiert. Bei den Quantitäten gibt es atomare, die nur einen Wert mit einer Einheit besitzen, und zusammengesetzte, die einen Vektor atomarer Quantitäten mit unterschiedlichen Einheiten darstellen, wobei die Einheiten alle im selben Einheitentyp typisiert sein müssen.

\subsubsection{Die Manager}

\subsubsubsection{UnitTypeManager}

Der UnitTypeManager beinhaltet zwei auf der Oberfläche sichtbare und zwei nicht sichtbare Listen zur Verwaltung von Einheiten (Units) und Einheitentypen (UnitTypes).

\begin{description}
\item[AbsUnitType** unitTypes] Diese Liste enthält alle Einheitentypen, die der Manager verwaltet.
\item[AbsUnit ** units] Hier werden alle Einheiten abgelegt, die der Manager verwaltet.
\item[ReferenceType** refTypes] Diese Liste enthält alle Referenz-Typen, die der Manager verwaltet. Sie ist nicht sichtbar und dient nur zur internen Verarbeitung von zusammengesetzten Einheitentypen (CompoundUnitTypes)
\item[Reference** refs] Hier werden alle Referenzen abgelegt, die der Manager verwaltet. Sie ist nicht sichtbar und dient nur zur internen Verarbeitung von zusammengesetzten Einheiten (CompoundUnits)
\end{description}

\subsubsubsection{FractionManager}\label{FractionManager}

Der FractionManager verwaltet alle Brüche so, dass jede Rationale Zahl als Bruch nur einmal durchgekürzt (als \emph{Repräsentant}) vorkommt.
Über die Operation \textit{getFraction(key:String):Fraction} wird auf einen vorhandenen Bruch zugegriffen, wobei der Schlüssel die \textit{toString-Ausgabe} des Bruchs ist.
Die Operation \textit{addFraction} wird ein neuer Bruch publiziert, wenn er erstmalig benötigt wird. Die Operation \textit{invertSign(f:Fraction):Fraction} sucht das Negativkomplement zu der Zahl und erstellt es, falls nötig.

GOJA unterstütz keine 3-stelligen Assoziationen bei denen der Wert eines Wert-Schlüssel-Paares ein in GOJA primitiver Typ ist. Deswegen wurde die Klasse \textit{FractionWrapper} erstellt, die den Wert des Bruchs umhüllt. Somit wird das Problem umgangen: \texttt{FractionWrapper **String** managedFractions;}


\subsubsubsection{QuantityManager}\label{QuantityManager}

Der QuantityManager verwaltet die Zugriffe auf Quantitäten und ist die Schnittstelle zum Erstellen neuer Exemplare.
Zudem wird der FractionManager als zentrale Fassade für das arithmetische und logische Operieren auf Quantitäten verwendet (siehe dazu Abschnitt \ref{Berechnungen}).

Beim Erstellen einer atomaren Quantität referenziert die \textit{amount}-Assoziation ein Fraction-Objekt aus dem FractionManager. Wird beim Anlegen der Quantität festgestellt, dass es diesen Bruch noch nicht gibt,
wird sie neu erstellt und im FractionManager publiziert. 

\subsubsection{Einheitentypen}
Die Einheitentypen (UnitTypes) geben an, welche verschiedenen Einheiten fachlich zusammen gehören. Beispielsweise sind Dollar und Euro beides Währungen und können damit zusammengerechnet werden. In diesem Fall ist der Einheitentyp Währung und die beiden zugehörigen Einheiten sind Dollar und Euro. Bei Euro und Kilometer hingegen macht es wenig Sinn, diese zu Addieren oder zu Subtrahieren, denn das eine ist eine Währung und das andere eine Strecken-Angabe. Die Multiplikation und Division hingegen können auch auf unterschiedlichen Einheitentypen geschehen, wodurch dann zusammengesetzte Einheitentypen (CompoundUnitTypes) wie Geschwindigkeit (Strecke/Zeit) entstehen.

Zur Verwaltung von UnitTypes und CompoundUnitTypes stellt der UnitTypeManager 8 transaktionale Operationen bereit. Folgende dieser Operationen sind direkt über die Oberfläche erreichbar:

\begin{description}
\item[createUnitType]
Diese Operation dient zum Erstellen eines neuen atomaren Einheitentypen. Da jeder Einheitentyp einen eigenen, eindeutigen Namen besitzen muss, wird dieser als Parameter der Operation übergeben. Sollte es schon einen Einheitentyp, egal ob atomar oder zusammengesetzt, mit diesem Namen geben, gibt es eine DoubleDefinitionException.
\item[fetchScalarType]
Liefert den skalaren Einheitentyp, welcher aus einem zusammengesetzten Einheitentypen ohne Referenzen auf atomare Typen besteht. 
\item[changeUTName]
Mit dieser Operation kann der Name eines Einheitentypen geändert werden. Ebenso wie beim neu erstellen, gibt es auch hier eine DoubleDefinitionException, wenn schon ein Einheitentyp mit diesem Namen existiert.
\item[addReferenceType]
Mit dieser Operation kann einem Einheitentypen, egal ob zusammengesetzt oder atomar, eine Referenz auf einen atomaren Einheitentypen hinzugefügt werden. Hierdurch entsteht dann ein zusammengesetzter Einheitentyp. Zusätzlich zu dem zu referenzierenden Einheitentypen muss noch der Exponent der Referenz und der Name des neu entstehenden zusammengesetzten Einheitentypen übergeben werden. Wie bei den anderen beiden Methoden gilt auch hier: ist der Name schon vorhanden, gibt es eine DoubleDefinitionException. Existiert schon ein Einheitentyp mit genau den selben Referenzen, wird kein neuer Einheitentyp erstellt, sondern der vorhandene zurückgegeben.
\item[setDefaultUnit]
Diese Methode weist einem atomaren Einheitentypen eine Standard-Einheit zu, die für Umrechnungen in andere Einheiten benötigt wird. Die Umrechnungen werden im Kapitel \ref{ConversionsKapitel} genauer erläutert.
\end{description}

Folgende Operationen sind für die interne Verarbeitung relevant und können nicht über die Oberfläche aufgerufen werden:

\begin{description}
\item[getExistingCUT]
Diese Operation ermittelt an Hand einer Liste von Referenzen, ob schon ein zusammengesetzter Einheitentyp mit genau diesen Referenzen existiert, und, wenn vorhanden, wird er zurückgegeben. 
\item[fetchCUT]
Diese Methode prüft zunächst an Hand einer Liste von Referenzen, ob schon ein Einheitentyp mit diesen existiert (dazu wird getExistingCUT verwendet) und legt, wenn nicht vorhanden, diesen neu an. Anschließend wird der Einheitentyp, der durch die übergebenen Referenzen definiert ist, zurückgegeben. Dafür muss auch ein Name übergeben werden, der jedoch nur beim Neu erstellen Verwendung findet. Auch hier gilt: Ist der Name schon vorhanden, gibt es eine DoubleDefinitionException. Diese Methode dient der Vermeidung von doppelt angelegten Einheitentypen.
\item[fetchReferenceType]
Diese Operation ermittelt, ob es schon eine Referenz auf einen Einheitentyp mit einem bestimmten Exponenten gibt. Wenn ja, wird sie zurückgegeben, wenn nicht, wird eine neue erstellt. Diese Methode dient der Vermeidung von doppelt angelegten Referenzen auf Einheitentypen.
\end{description}


\subsubsection{Einheiten}
Fachlich gesehen können Einheiten (Units) von Quantitäten angenommen werden und sind in Einheitentypen typisiert.
Dabei wird zwischen atomaren Einheiten (z.B. Meter [m]) und zusammengesetzten Einheiten (z.B. Kilometer pro Stunde [km/h]) unterschieden.

\subsubsubsection{Objektmodell}

Die Zusammenhänge zwischen Units und UnitTypes sollen an dieser Stelle anhand eines beispielhaften Objektmodells in \refImg{unit_unittypes_objektmodell} verdeutlicht werden.

\img[width=\relWidth{1}]{quantity/unit_unittypes_objektmodell.png}{Objektmodell: Geschwindigkeit und Beschleunigung}{unit_unittypes_objektmodell}

Auf der Typebene gibt es die beiden atomaren UnitTypes \textit{Strecke} und \textit{Zeit}, außerdem zwei CompoundUnitTypes \textit{Geschwindigkeit} und \textit{Beschleunigung}. \textit{Geschwindigkeit} hat zwei Referenzen (RefTypes), eine mit dem Exponent 1 auf \textit{Strecke} und eine mit dem Exponenten -1 auf \textit{Zeit}. \textit{Beschleunigung} hat ebenfalls eine Referenz mit dem Exponenten 1 auf \textit{Strecke}. Hierbei wird dasselbe RefType-Objekt verwendet, welches auch \textit{Geschwindigkeit} nutzt. Außerdem besitzt \textit{Beschleunigung} noch eine Referenz auf \textit{Zeit}. Da diese jedoch den Exponenten -2 hat, wird hierbei ein anderes RefType-Objekt verwendet als bei \textit{Geschwindigkeit}.

Auf der Exemplarebene gibt es die atomaren Units \textit{km}, typisiert in \textit{Strecke}, und \textit{h} und \textit{s}, beide typisiert in \textit{Zeit}. Außerdem gibt es die CompoundUnits \textit{km/h}, welche als Einheitentyp \textit{Geschwindigkeit} hat, und \textit{km/(s*h)}, welche zum Einheitentyp \textit{Beschleunigung} gehört. Auf \textit{km} gibt es eine Referenz mit Exponent 1, welche sowohl von \textit{km/h} als auch von \textit{km/(s*h)} verwendet wird. Die Referenz mit Exponent -1 auf \textit{h} wird ebenfalls von \textit{km/h} und \textit{km/(s*h)} benutzt. Außerdem geht von \textit{km/(s*h)} aus noch eine Referenz mit Exponenten -1 auf \textit{s}. Somit gibt es auf der Exemplarebene von der \textit{Beschleunigungs}-Einheit zwei Referenzen auf \textit{Zeit}-Einheiten. Summiert man jedoch ihre Exponenten, erhält man den auf der Typebene geforderten Exponenten -2.

\subsubsubsection{Konsistenzbedingungen}

Folgende konsistenzbedingungen stellen sicher, dass sich Einheiten und Einheitentypen Konsistent zueinander verhalten:

\begin{equation} \forall ut \in UnitType : ut.defaultUnit.type = ut \end{equation}

\begin{equation} \forall cut \in CompUnitType, r_1, r_2 \in cut.refs : r_1.ref = r_2.ref \Rightarrow r_1 = r_2 \end{equation}

\begin{equation} \forall r \in RefType : r.exponent \ne 0 \end{equation}

\begin{equation} \forall r \in Ref : r.exponent \ne 0 \end{equation}

\begin{equation} \forall cu \in CompUnit:
\forall rt \in cu.types.refs:
ut \in rt.ref \Rightarrow rt.exp = \sum_{s \in \bigcup \{ x \in cu.refs | x.ref.type = ut \}} s.exp \end{equation}

\begin{equation} \forall cu \in CompUnit :
\forall u \in cu.refs.ref \exists ut \in cu.type.refs.ref : u.type = ut \end{equation}

\subsubsubsection{Verwalten von Units}

Für die Verwaltung von Units und CompoundUnits stellt der UnitTypeManager acht transaktionale Operationen bereit.
Folgende dieser Operationen sind direkt über die Oberfläche erreichbar:

\begin{description}
\item[createUnit]
Diese Operation dient zum Erstellen einer neuen Unit. Da jede Unit fachlich in einem UnitType typisiert werden und einen Namen haben muss, können dieser Methode diese Werte entsprechend übergeben werden. Eine DoubleDefinitionException wird geworfen, wenn eine Unit mit dem gewählten Namen bereits existiert.
\item[changeUName]
Diese Operation dient zum Umbenennen einer Unit. Auch hier wird die DoubleDefinitionException im doppelten Namensfall geworfen.
\item[fetchScalar]
Liefert die eine CompoundUnit, die keine Referenzen zu anderen Units aufweist.
\item[addReference]
Diese Operation kann sowohl auf zusammengesetzten Einheiten, als auch auf atomaren Einheiten angewendet werden. Sie dient zum erstellen von CompoundUnits. Analog zur createUnit-Methode wird hier ein Name benötigt. Die entsprechende neue Referenz zur ausgewählten Unit wird durch einen Exponenten definiert. Die DoubleDefinitionException wird auch hier geworfen, falls es zu Namenskonflikten kommt.
\item[setConversion]
Mittels dieser Operation lässt sich für eine Unit eine Conversion zur aktuellen DefaultUnit des entsprechenden UnitTypes angeben. Die Umrechnungsrate besteht immer aus einem Faktor und einer Konstante. Die Conversions werden im Kapitel \ref{ConversionsKapitel} näher erläutert.
\end{description}

Folgende Operationen sind für die interne Verarbeitung relevant und können nicht über die Oberfläche aufgerufen werden:
\begin{description}

\item[getExistingCU]
Hier wird anhand einer Liste von vorhandenen Referenzen eine CompoundUnit ermittelt, welche durch genau diese Referenzen definiert ist. Sollte diese Unit noch nicht existieren, wird null zurückgeliefert. Diese Operation dient zum vermeiden von doppelt angelegten CompoundUnits.
\item[fetchCU]
Diese Operation ist ähnlich der getExistingCU()-operation. jedoch wird hierbei die CompoundUnit angelegt, falls sie noch nicht existiert. Die Angabe eines Namens ist erforderlich, falls eine neue CompoundUnit zustande kommen sollte. Auch hier wird entsprechend eine DoubleDefinitionException geworfen, falls eine Unit mit dem gewählten Namen bereits existiert.
\item[fetchReference]
Mithilfe dieser Operation kann eine Referenz-Instanz mit einem gewissen Exponenten auf eine bestimmte Unit ermittelt werden. Falls diese Instanz noch nicht existierte, wird sie erzeugt. Das dient zum vermeiden von Doppelt anlegten Referenzen.
\end{description}

\subsubsubsection{Conversions}\label{ConversionsKapitel} 

Eine Conversion, also die Umrechnung von einer Unit zur entsprechend zum UnitType gehörigen DefaultUnit, kann über zwei Wege zustande kommen, bzw. verändert werden: Zum einen über die setConversion-Operation und zum anderen über die setDefaultUnit-Operation.
Conversions sind immer lineare Funktionen, damit eine Umkehrbarkeit gewährleistet ist. Jede Conversion enthält also einen Faktor und eine Konstante (als Fraction), um der linearen Funktion m*x+b gerecht zu weden. Die Angabe von m und b hat folgende Semantik: y DefaultUnit = m * unitWert + b.
Am Beispiel von Fahrenheit und Celsius würde für Celsius die Conversion folgendermaßen lauten, wenn Fahrenheit die DefaultUnit darstellt:

\begin{equation} Wert_{^\circ F} = Wert_{^\circ C} * \frac{9}{5} + 32
\end{equation}

Mittels setConversion() wird eine bereits gesetzte Conversion für eine Unit überschrieben.
Bei setDefaultUnit() wird eine Umrechnung von bereits vorhanden Conversions notwendig, da diese ja in Abhängigkeit zu einer nun veralteten DefaultUnit angegeben wurden. Das betrifft alle Umrechnungen für Units zum selben UnitType wie die DefaultUnit.
\refImg{setDefaultUnitGrafik} beschreibt die Umrechnungen, falls sich eine DefaultUnit ändert.
\img[width=\relWidth{0.8}]{quantity/setDefaultUnit.png}{Umrechnung beim Ändern einer DefaultUnit}{setDefaultUnitGrafik}
Im gezeigten Beispiel gibt es drei Einheiten a, b und c, wobei zunächst a die DefaultUnit zum gemeinsamen UnitType darstellt (oberer Bereich). Die DefaultUnit kann nur den Umrechnungsfaktor 1 haben, da die Funktion immer umkehrbar ist (1a=1a). Für den unteren Bereich der Abbildung wird dann die DefaultUnit auf b gesetzt. Die jeweils neuen Conversions ergeben sich, indem die jeweilige Funktion der Unit mit der noch aktuellen Funktion der neuen DefaultUnit (also b) gleich gesetzt wird und mittels Äquivalenzumformung zur neuen DefaultUnit hin umgestellt wird (rechter Bereich). Für die neue DefaultUnit ist danach der Umrechnungsfaktor dann entsprechend wieder 1.

Die entsprechende Konsistenzbedingung für diesen Fall lautet wie folgt:

\begin{equation} \forall ut \in UnitType : ut.defaultUnit.from^{-1}.myFunction.factor = 1 \wedge ut.defaultUnit.from^{-1}.myFunction.constant = 1 \end{equation}

\subsubsection{Quantitäten}\label{Quantitaeten}

\subsubsubsection{Einfache und zusammengesetzte Quantitäten}

Quantitäten können sowohl atomar als auch zusammengesetzt sein.
Dies wird definiert die parts-Assoziation zwischen \term{CompoundQuantity} und \term{Quantity}. 
Dabei kann man zusammengesetzte Quantitäten als Vektoren auffassen, deren Elemente einfache Quantitäten sind. 
\emph{In einem Vektor dürfen nur solche Quantiäten enthalten sein, die mit dem gleichen UnitType assoziiert sind}. 

\subsubsubsection{Berechnungen und Vergleiche}\label{Berechnungen}

Die Addition, Subtraktion, Division und Multiplikation sind als Grundrechenarten (BasicCalculation) im Klassenmodell dargestellt. Man unterscheidet zwischen Grundrechenarten, die die Referenzen der Einheit verändern, und solchen, die dies nicht tun. Z.B. ergibt die Addition zweier Längenangaben (z.B. Meter) wieder eine Längenangabe. Also nennen wir eine solche Rechnung \emph{einheitstypbewahrend}. Im Klassenmodell ist diese Generalisierung als die Klasse \textit{UnitImutabCalc} zu erkennen. Im Gegensatz dazu ergibt z.B. die Multiplikation zweier Längenangaben eine Flächenangabe (z.B. Quadratmeter). Wir nennen diese Rechnungen \emph{einheitstypverändernd} - im Klassenmodell als \textit{UnitMutabCalc} zu sehen. Diese Implementierung besitzt Ansätze eines \emph{Kommando-Entwurfsmusters}.

\subsubsubsection{Berechnungslogik}

Werden zweistellige Operationen zwischen AbsQuantity-Exemplaren ausgeführt, treten abhängig vom Typ der Quantität 3 Fälle auf:
\begin{enumerate}
\item \textit{op(vektor, vektor)}
\item \textit{op(vektor, element)}
\item \textit{op(element, element)}
\end{enumerate}

Die Methode der Operation \textit{calculate} der Klasse \textit{BasicCalculation} ermittelt mit Hilfe von \emph{Visitoren} die auszuführende Logik und ruft nach dem Template-Entwurfsmuster die entsprechende Methode auf, die in der zweiten Stufe der Klassenhierarchie implementiert werden, nämlich in \textit{UnitImutabCalc} und \textit{UnitMutabCalc}:
\begin{itemize}
\item \textit{calc1Compound1Atomar}
\item \textit{calcAtomar}
\item \textit{calcComp}
\end{itemize}

Das Rechnen mit zusammengesetzten Quantitäten folgt den allgemeinen Gesetzten der Vektorenrechnung.

Die Addition und Subtraktion funktioniert nur mit \emph{einheitstypgleichen} Quantitäten. Dagegen funktioniert die Multiplikation und Division mit allen Quantitäten, vorausgesetzt, es wird eine \emph{Zieleinheit}, bzw. ein \emph{Zieleinheitstyp} gefunden. Ist dies nicht der Fall wird eine \emph{Ausnahme} ausgelöst. Die Signatur der Klasse 
\textit{UnitMutabCalc} ist bereits darauf vorbereitet, automatisch Einheiten und Typen zu generieren, sollte noch keine Zieleinheit als \emph{Unit-Stammsatz} angelegt sein. Zum Zeitpunkt der Fertigstellung dieser Dokumentation ist dieser Automatismus noch nicht implementiert.

Der einzige bisher implementierte logische Verglich \emph{isLessOrEqual} folgt genau dem gleichen Schema, ist jedoch nur als eine Klasse \textit{LessOrEqualComparison} realisiert.
