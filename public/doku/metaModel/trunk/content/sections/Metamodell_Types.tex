\subsection{Typesystem}

\subsubsection{Aspekte und atomare Typen}

Aspekte stellen gemäß ursprünglichen Modellierung eine Dimension dar, in deren Elementen sich Objekte dynamisch klassifizieren lassen. 
Atomare Typen der Klasse \emph{AtomicType} werden genau einem Aspekt zugeordnet. Durch die \emph{lessThan}-Assoziation lässt sich aspektintern eine 
partielle Ordnung \emph{isLessOrEqualThan} ableiten.  

\img[width=\relWidth{0.75}]{type/Aspekte.png}{Umarrangierter Ausschnitt Aspekte}{img_aspekts}

Das Interface \emph{AnythingORMATomicType} ist als Zieltyp der \emph{lessThan}-Assoziation ergänzt worden, 
um die Möglichkeit zu schaffen einen atomaren Typen mit Obertyp so zu ändern, dass er anschließend keinen 
Obertypen mehr besitzt. Folgende Möglichkeiten wurden in der Entwurfsphase betrachtet: 
\begin{enumerate}
  		\item superType Assoziation mit Multiplizität 0..1
		\item State-Pattern für atomare Typen \(state \in \{rootType, subType\}\)
        \item automatisch mitgenerierte Obertypen für Aspekte
        \item Interface über Anything und AtomicType
\end{enumerate}

Die erste Variante lässt sich in GOJA aufgrund der restriktiven Set-Methoden nicht realisieren, da diese keine NULL-Werte akzeptieren.
Ein State-Pattern wäre die sauberste Implementierung gewesen, ist aber wegen fehlenden Mehrwertes ausgeschieden. 
Variante drei hat den Nachteil, dass die mitgenerierten Typen die Semantik \qq{unkategorisiert} im zugehörigen Aspekt besitzen.
Damit wird pro Aspekt ein Platzhalter für Null generiert und sorgt für zusätzliche Komplexität ohne Mehrwert. 
Da ohne State-Pattern aber eine Repräsentation für keinen atomaren Obertypen benötigt wird, wird an dieser Stelle \emph{Anything} verwendet 
da es ohnehin Obertyp eines jeden Typen ist. Dies ist insofern unsauber, als das \emph{Anything} nicht Teil eines einzigen Aspektes ist.
Weitere Nachteile sind bisher nicht ersichtlich.


\subsubsubsection{Aspekte}

\textbf{Zusätzliche Konsistenzbedinungen} \newline
Die einzige Konsistenzbedingung von Aspekten ist, dass sie paarweise verschiedene Namen tragen müssen. 

\textbf{Manager} \newline
Aspekte werden vom \emph{AspectManager} verwaltet. Alle Operation werden transaktional aufgerufen und prüfen die Konsistenzbedingung. 

\begin{description}
\item[createAspect] legt einen neuen Aspekt an.
\item[renameAspect] benennt einen Aspekt um.
\item[deleteAspect] loescht einen Aspekt, wenn keine abhängingen Modellelemente existieren.
\end{description}

\textbf{Abhängige Elemente}
\begin{enumerate}
  		\item Atomare Typen, die in diesem Aspekt angelegt sind.
\end{enumerate}


\subsubsubsection{Atomare Typen}

\textbf{Zusätzliche Konsistenzbedinungen}
\begin{enumerate}
  		\item Paarweise verschiedene Namen in einem Aspekt
  		\item \(\forall a \in AT : !(a.singleton \land a.abstract) \)
\end{enumerate}

\textbf{Manager} \newline
Atomare Typen werden vom \emph{TypeManager} verwaltet. 

\begin{description}
\item[createAtomicRootType] legt einen neuen atomaren Typen mit Obertyp \emph{Anything} an. 
\item[createAtomicSubType] legt einen neuen atomaren Typen unter einem andern an. 
\item[renameAtomicType] benennt einen atomaren Typen um. 
\item[changeAbstract] ist eine modifizierte Set-Methode. Kann einen konkreten Typen nur abstrakt umdeklarieren, wenn er weder Singletons ist, noch 
Objekte in ihm klassifiziert sind.
\item[changeSingleton] ist eine modifizierte Set-Methode. Kann die Singletoneigenschaft nur wiederrufen, wenn das \emph{SingletonObject} gelöscht werden kann. 
 Kann die Singletoneigenschaft nur gewähren, wenn keine Objekte existieren und der Typ nicht abstrakt ist. 
\end{description}

\textbf{Singletons} \newline
Die Singletoneigenschaft eines atomaren Typen A bedeutet ausschließlich, dass genau ein Objekt existiert, dessen konkretester Typ A ist.
Von Singletons darf beliebig abgeleitet werden. 
In der \emph{initializeOnCreation}-Operation des atomaren Typen wird, falls er über die Singletoneigenschaft verfügt, 
sein \emph{SingletonObject} erstellt. In der \emph{prepareForDeletion}-Operation wird - falls vorhanden - das \emph{SingeletonObject}
mitgelöscht. Die \emph{changeSingleton}-Operation verwaltet ebenfalls \emph{SingletonObject}s. 
 
\textbf{Abhängige Elemente}
\begin{enumerate}
  		\item Atomare Typen: direkte Untertypen
  		\item bei Singletons: Abhängige Objekte des \emph{SingletonObject}s
  		\item \ldots siehe Typabstraktion
\end{enumerate}

\subsubsection{Komplexe Typen}

Komplexe Typen bieten die Möglichkeit Und- und Oder-Typen zu bilden. Zyklenfreiheit wird hierbei dadurch gewährleistet, 
dass \emph{containedTypes} und alle Spezialisierungen Teil einer Hierarchie sind. Komplexe Typen sind immutable,
lassen sich aber (bis auf \emph{Anything} und \emph{Nothing}) löschen, falls keine Abhängigkeiten existieren.

\img[width=\relWidth{1}]{type/ComplexTypes.png}{Ergänzter Ausschnitt: Komplexe Typen}{img_complexTypes}

Um für Unterklassen von \emph{ComplexType} die Assoziation \emph{containedTypes} weiter einschränken zu 
können, ist sie spezialisiert worden. Ursprünglich ist \emph{containedTypes} abgeleitetes Attribut gewesen,
ist aber wegen Problemen in GOJA zu einer \emph{fetch}-Operation refaktoriert worden. 
Ziel ist, z.B. in den leeren Typen keine Änderungen an der Assoziation zu erlauben und diese für die Bereitstellung 
der disjunktiven Normalform mit weiteren Contraints zu versehen (siehe z.B. \emph{NonEmptyAtomicTypeConjunction}) 



\TODO[Kapitel schreiben]