\subsection{Typesystem}

\subsubsection{Aspekte und atomare Typen}

Aspekte stellen gemäß ursprünglichen Modellierung eine Dimension dar, in deren Elementen sich Objekte dynamisch klassifizieren lassen. 
Atomare Typen der Klasse \emph{AtomicType} werden genau einem Aspekt zugeordnet. Durch die \emph{lessThan}-Assoziation lässt sich aspektintern eine 
partielle Ordnung \emph{isLessOrEqualThan} ableiten.  

\img[width=\relWidth{0.5}]{type/Aspekte.png}{Umarrangierter Ausschnitt Aspekte}{img_aspekts}

Das Interface \emph{AnythingORMATomicType} ist als Zieltyp der \emph{lessThan}-Assoziation ergänzt worden, 
um die Möglichkeit zu schaffen einen atomaren Typen mit Obertyp so zu ändern, dass er anschließend keinen 
Obertypen mehr besitzt. Folgende Möglichkeiten wurden in der Entwurfsphase betrachtet: 
\begin{enumerate}
  		\item superType Assoziation mit Multiplizität 0..1
		\item State-Pattern für atomare Typen \(state \in \{rootType, subType\}\)
        \item automatisch mitgenerierte Obertypen für Aspekte
        \item Interface über Anything und AtomicType
\end{enumerate}

Die erste Variante lässt sich in GOJA aufgrund der restriktiven Set-Methoden nicht realisieren, da diese keine NULL-Werte akzeptieren.
Ein State-Pattern wäre die sauberste Implementierung gewesen, ist aber wegen fehlenden Mehrwertes ausgeschieden. 
Variante drei hat den Nachteil, dass die mitgenerierten Typen die Semantik \qq{unkategorisiert} im zugehörigen Aspekt besitzen.
Damit wird pro Aspekt ein Platzhalter für Null generiert und sorgt für zusätzliche Komplexität ohne Mehrwert. 
Da ohne State-Pattern aber eine Repräsentation für keinen atomaren Obertypen benötigt wird, wird an dieser Stelle \emph{Anything} verwendet 
da es ohnehin Obertyp eines jeden Typen ist. Dies ist insofern unsauber, als das \emph{Anything} nicht Teil eines einzigen Aspektes ist.
Weitere Nachteile sind bisher nicht ersichtlich.


\subsubsubsection{Aspekte}

\textbf{Zusätzliche Konsistenzbedinungen} \newline
Die einzige Konsistenzbedingung von Aspekten ist, dass sie paarweise verschiedene Namen tragen müssen. 

\textbf{Manager} \newline
Aspekte werden vom \emph{AspectManager} verwaltet. Alle Operation werden transaktional aufgerufen und prüfen die Konsistenzbedingung. 

\begin{description}
\item[createAspect] legt einen neuen Aspekt an.
\item[renameAspect] benennt einen Aspekt um.
\item[deleteAspect] loescht einen Aspekt, wenn keine abhängingen Modellelemente existieren.
\end{description}

\textbf{Abhängige Elemente}
\begin{enumerate}
  		\item Atomare Typen, die in diesem Aspekt angelegt sind.
\end{enumerate}


\subsubsubsection{Atomare Typen}

\textbf{Zusätzliche Konsistenzbedinungen}
\begin{enumerate}
  		\item Paarweise verschiedene Namen in einem Aspekt
  		\item \(\forall a \in AT : !(a.singleton \land a.abstract) \)
\end{enumerate}

\textbf{Manager} \newline
Atomare Typen werden vom \emph{TypeManager} verwaltet. 

\begin{description}
\item[createAtomicRootType] legt einen neuen atomaren Typen mit Obertyp \emph{Anything} an. 
\item[createAtomicSubType] legt einen neuen atomaren Typen unter einem andern an. 
\item[renameAtomicType] benennt einen atomaren Typen um. 
\item[changeAbstract] ist eine modifizierte Set-Methode. Kann einen konkreten Typen nur abstrakt umdeklarieren, wenn er weder Singletons ist, noch 
Objekte in ihm klassifiziert sind.
\item[changeSingleton] ist eine modifizierte Set-Methode. Kann die Singletoneigenschaft nur wiederrufen, wenn das \emph{SingletonObject} gelöscht werden kann. 
 Kann die Singletoneigenschaft nur gewähren, wenn keine Objekte existieren und der Typ nicht abstrakt ist. 
\end{description}

\textbf{Singletons} \newline
Die Singletoneigenschaft eines atomaren Typen A bedeutet ausschließlich, dass genau ein Objekt existiert, dessen konkretester Typ A ist.
Von Singletons darf beliebig abgeleitet werden. 
In der \emph{initializeOnCreation}-Operation des atomaren Typen wird, falls er über die Singletoneigenschaft verfügt, 
sein \emph{SingletonObject} erstellt. In der \emph{prepareForDeletion}-Operation wird - falls vorhanden - das \emph{SingeletonObject}
mitgelöscht. Die \emph{changeSingleton}-Operation verwaltet ebenfalls \emph{SingletonObject}s. 
 
\textbf{Abhängige Elemente}
\begin{enumerate}
  		\item Atomare Typen: direkte Untertypen
  		\item bei Singletons: Abhängige Objekte des \emph{SingletonObject}s
  		\item \ldots siehe Typabstraktion
\end{enumerate}

\subsubsection{Komplexe Typen}



\TODO[Kapitel schreiben]